- [1. 介绍](#1-介绍)
  - [1.1. 要求记号](#11-要求记号)
  - [1.2. 语法记号](#12-语法记号)
- [2. 架构](#2-架构)
  - [2.1. 客户/服务器交换报文](#21-客户服务器交换报文)
  - [2.2. 实现多样性](#22-实现多样性)
  - [2.3. 中介](#23-中介)
  - [2.4. 缓存](#24-缓存)
  - [2.5. 符合性和错误处理](#25-符合性和错误处理)
  - [2.6. 协议版本](#26-协议版本)
  - [2.7. 统一资源标识符(URI)](#27-统一资源标识符uri)
    - [2.7.1. http URI 方案](#271-http-uri-方案)
    - [2.7.2. https URI 方案](#272-https-uri-方案)
    - [2.7.3. http 和 https URI 的标准化和比较](#273-http-和-https-uri-的标准化和比较)
- [3. 报文格式](#3-报文格式)
  - [3.1. 起始行](#31-起始行)
    - [3.1.1. 请求行](#311-请求行)
    - [3.1.2. 状态行](#312-状态行)
  - [3.2. 首部字段](#32-首部字段)
    - [3.2.1. 字段扩展性](#321-字段扩展性)
    - [3.2.2. 字段顺序](#322-字段顺序)
    - [3.2.3. 空白](#323-空白)
    - [3.2.4. 字段解析](#324-字段解析)
    - [3.2.5. 字段限制](#325-字段限制)
    - [3.2.6. 字段值部分](#326-字段值部分)
  - [3.3. 报文体](#33-报文体)
    - [3.3.1. Transfer-Encoding](#331-transfer-encoding)
    - [3.3.2. Content-Length](#332-content-length)
    - [3.3.3. 报文体长度](#333-报文体长度)
  - [3.4. 处理不完整的报文](#34-处理不完整的报文)
  - [3.5. 报文解析健壮性](#35-报文解析健壮性)

# 1. 介绍

**超文本传输协议(Hypertext Transfer Protocol, HTTP)** 是一个无状态的应用级请求/响应协议，它使用可扩展的语义和自我描述的报文有效载荷，与基于网络的超文本报文系统进行灵活的交互。本文件是一系列文件中的第一个，这些文件共同构成了 HTTP/1.1 规范：

1. “报文语法和路由”（本文件）
2. “语义和内容” [RFC 7231]
3. “条件请求” [RFC 7232]
4. “范围请求” [RFC 7233]
5. “缓存” [RFC 7234]
6. “认证” [RFC 7235]

这个 HTTP/1.1 规范废除了 RFC 2616 和 RFC 2145（关于 HTTP 版本）。该规范还更新了以前在 RFC 2817 中定义的使用 CONNECT 建立隧道的方法，并定义了在 RFC 2818 中非正式描述的 “https” URI 方案。

HTTP 是一个报文系统的通用接口协议。它旨在通过向客户提供一个独立于所提供的资源类型的统一接口，来隐藏服务实现的细节。同样，服务器也不需要知道每个客户的目的：一个 HTTP 请求可以被独立地考虑，而不是与特定类型的客户或预先确定的应用步骤序列相关联。其结果是一个可以在许多不同的环境中有效使用的协议，其实现可以随着时间的推移独立发展。

HTTP 也被设计为一种中介协议，用于转译与非 HTTP 报文系统的通信。HTTP 代理和网关可以提供对其他报文服务的访问，将其不同的协议转译成超文本格式，可以被客户以与 HTTP 服务相同的方式查看和操作。

这种灵活性的一个后果是，不能用接口后面发生的事情来定义协议。相反，我们只限于定义通信的语法、接收通信的意图以及接收方的预期行为。如果通信被孤立地考虑，那么成功的行动应该反映在对服务器提供的可观察界面的相应改变中。然而，由于多个客户可能平行行动，而且可能是交叉行动，我们不能要求这种变化在单个响应的范围之外可以观察到。

本文件描述了在 HTTP 中使用或提及的架构的基本组成，定义了 “http” 和 “https” URI 方案，描述了整体网络运作和连接管理，并定义了 HTTP 报文架构和转发要求。我们的目标是定义所有独立于报文语义的 HTTP 报文处理所需的机制，从而为报文解析器和报文转发中介机构定义一套完整的要求。

## 1.1. 要求记号

本文档中的关键词 "必须"、"不得"、"需要"、"Shall"、"SHALL NOT"、"应该"、"推荐"、可以" 和 "可选" 应按照[RFC 2119]中的描述进行解释。

有关错误处理的符合性标准和注意事项在第 2.5 节中定义。

## 1.2. 语法记号

本规范使用 [RFC 5234] 的 Augmented Backus-Naur Form (ABNF) 计法，并在第 7 节中定义了一个列表扩展，允许使用'#'运算符（类似于'\*'运算符表示重复的方式）紧凑地定义逗号分隔的列表。附录 B 显示了收集的语法，其中所有的列表操作符都扩展为标准的 ABNF 符号。

以下核心规则通过参考包括在 [RFC 5234] 附录 B.1 中的定义。ALPHA（字母）、CR（回车）、CRLF（CR LF）、CTL（控制）、DIGIT（十进制 0-9）、DQUOTE（双引号）、HEXDIG（十六进制 0-9/A-F/a-f）、HTAB（水平制表符）、LF（换行）、OCTET（任何 8 位数据序列）、SP（空格）和 VCHAR（任何可见[USASCII]字符）。

按照惯例，ABNF 规则名称前缀为 "obs-"，表示由于历史原因出现的 "过时 "语法规则。

# 2. 架构

HTTP 是为万维网(WWW)架构而创建的，并随着时间的推移不断发展，以支持全球超文本系统的可扩展性需求。该架构的大部分内容反映在用于定义 HTTP 的术语和语法产生式上。

## 2.1. 客户/服务器交换报文

HTTP 是一个无状态的请求/响应协议，通过可靠的传输层或会话层的 “连接”（第 6 节）交换报文（第 3 节）。一个 HTTP “**客户(client)**” 是一个程序，它建立了一个与服务器的连接，目的是发送一个或多个 HTTP 请求。HTTP “**服务器(server)**” 是一个接受连接的程序，以便通过发送 HTTP 响应来服务 HTTP 请求。

术语 "客户"和 "服务器" 仅指这些程序在特定连接中所扮演的角色。同一个程序可能在某些连接上充当客户，而在其他连接上充当服务器。术语 "**用户代理(user agent)**" 是指发起请求的各种客户程序，包括（但不限于）浏览器、爬虫（基于网络的机器人）、命令行工具、定制化应用程序和移动应用程序。术语 "**源服务器(origin server)**" 指的是能够为特定目标资源发起权威响应的程序。术语 "**发送方(sender)**"和 "**接收方(recipent)**"分别指发送或接收特定报文的任何实现。

HTTP 依靠 **统一资源标识符(Uniform Resource Identifier, URI)** 标准[RFC 3986]来表示目标资源（第 5.1 节）和资源之间的关系。报文的传递格式类似于互联网邮件[RFC 5322]和多用途互联网邮件扩展（MIME）[RFC 2045]所使用的格式（关于 HTTP 和 MIME 报文的区别，请参见[RFC 7231]的附录 A）。

大多数 HTTP 通信包括对由 URI 识别的某些资源的表示的检索请求（GET）。在最简单的情况下，这可能是通过用户代理（UA）和源服务器（O）之间的单一双向连接（==）完成的。

```
        请求 >>>
UA ======================================= O
                                <<< 响应
```

客户以请求报文的形式向服务器发送一个 HTTP 请求，以包括方法、URI 和协议版本的请求行开始（第 3.1.1 节），然后是包含请求修饰词、客户报文和表示元数据的首部字段（第 3.2 节），一个空行表示首部的结束，最后是包含有效载荷的报文体（如果有的话，第 3.3 节）。

服务器通过发送一个或多个 HTTP 响应报文来响应客户的请求，每个响应报文以一个状态行开始，其中包括协议版本、成功或错误代码以及文本原因短语（第 3.1.2 节），后面可能是包含服务器报文、资源元数据和表示元数据的首部字段（第 3.2 节），一个空行表示首部的结束，最后是包含有效载荷的报文体（如果有的话，第 3.3 节）。

一个连接可能用于多个请求/响应交互，如第 6.3 节所定义。

下面的例子说明了 URI "http://www.example.com/hello.txt"的GET请求（[RFC 7231]第 4.3.1 节）的典型报文交互。

客户请求：

```http
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi
```

服务器响应：

```http
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain

Hello World! My payload includes a trailing CRLF.
```

## 2.2. 实现多样性

在考虑 HTTP 的设计时，很容易落入一个陷阱，认为所有的用户代理都是通用的浏览器，所有的源服务器都是大型的公共网站。实际情况并非如此。常见的 HTTP 用户代理包括家用电器、音响、天平、固件更新脚本、命令行程序、移动应用程序以及各种形状和大小的通信设备。同样，常见的 HTTP 源服务器包括家庭自动化装置、可配置的网络部分、办公机器、自动机器人、新闻源、交通摄像首部、广告选择器和视频交付平台。

术语 "用户代理" 并不意味着在请求时有一个人类用户直接与软件代理进行互动。在许多情况下，用户代理被安装或配置为在后台运行，并保存其结果供以后检查（或只保存那些可能有趣或错误的结果的子集）。例如，爬虫通常被赋予一个起始 URI，并被配置为在作为超文本图抓取网络时遵循某些行为。

HTTP 的实现多样性意味着并非所有的用户代理都能向他们的用户提出交互式建议，或为安全或隐私问题提供足够的警告。在本规范要求向用户报告错误的少数情况下，这种报告只在错误控制台或日志文件中可以观察到是可以接受的。同样地，要求自动操作在进行之前由用户确认的要求可以通过预先的配置选择、运行时选项或简单地避免不安全的动作；如果用户已经做出了选择，确认并不意味着任何特定的用户界面或中断正常处理。

## 2.3. 中介

HTTP 允许使用中介，通过一连串的连接来满足请求。有三种常见的 HTTP 中介形式：代理、网关和隧道。在某些情况下，一个中介可能充当源服务器、代理、网关或隧道，根据每个请求的性质切换行为。

```
    >>>         >>>         >>>         >>>
UA =========== A =========== B =========== C =========== O
            <<<             <<<           <<<        <<<
```

上图显示了用户代理和源服务器之间的三个中介（A、B 和 C）。一个穿越整个链条的请求或响应报文将通过四个独立的连接。一些 HTTP 通信选项可能只适用于与最近的、非隧道邻接节点的连接，只适用于链的端点，或适用于沿链的所有连接。尽管图表是线性的，但每个参与者都可能参与多个同时进行的通信。例如，B 在处理 A 的请求的同时，可能正在接收来自 A 以外的许多客户的请求，和/或将请求转发给 C 以外的服务器。同样，后来的请求可能会通过不同的连接路径发送，通常是基于负载平衡的动态配置。

术语 "**上游(upstream)**" 和 "**下游(downstream)**" 用于描述与报文流有关的方向性要求：所有报文都从上游流向下游。术语 "**(inbound)**" 和 "**出站(outbound)**" 用于描述与请求路线有关的方向性要求。"入站" 是指朝向源服务器，"出站" 是指朝向用户代理。

**代理(proxy)**"是一个报文转发代理，由客户选择，通常通过本地配置规则，接收对某些类型的绝对 URI 的请求，并试图通过 HTTP 接口的转译来满足这些请求。一些转译是最小的，例如对 “http” URI 的代理请求，而其他请求可能需要转译成完全不同的应用级协议。为了安全、注释服务或共享缓存，代理通常被用来通过一个共同的中介来组合一个组织的 HTTP 请求。一些代理被设计成在转发时对选定的报文或有效载荷进行转换，如 5.7.2 节所述。

**网关(gateway)** "（又称 "反向代理"）是一个中介，它作为出站连接的源服务器，它转译收到的请求并将其转发到另一个或多个服务器。网关经常被用来封装传统的或不被信任的报文服务，通过 "加速器" 缓存来提高服务器的性能，并实现 HTTP 服务在多台机器上的分区或负载平衡。

所有适用于源服务器的 HTTP 要求也适用于网关的出站通信。网关使用它所希望的任何协议与入站服务器进行通信，包括本规范范围之外的 HTTP 的私有扩展。然而，一个希望与第三方 HTTP 服务器互通的 HTTP-to-HTTP 网关应该符合网关入站连接的用户代理要求。

**隧道(tunnel)** "作为两个连接之间的无目的中继，不改变报文。一旦激活，隧道不被认为是 HTTP 通信的一方，尽管隧道可能是由一个 HTTP 请求发起的。当中继连接的两端都关闭时，隧道就不存在了。隧道被用来通过一个中介扩展一个虚拟连接，例如，当传输层安全（TLS，[RFC 5246]）被用来通过一个共享的防火墙代理建立保密通信。

上述中介的类别只考虑那些作为 HTTP 通信的参与者。也有一些中介可以在网络协议栈的较低层发挥作用，在报文发送方不知情或没有许可的情况下过滤或重定向 HTTP 流量。网络中介（在协议层面）与中间人攻击没有区别，往往由于错误地违反了 HTTP 语义而引入安全缺陷或互操作性问题。

例如，"拦截代理"[RFC 3040]（通常也被称为 "透明代理"[RFC 1919]或 "圈养门户"）与 HTTP 代理不同，因为它不是由客户选择的。相反，拦截代理过滤或重定向传出的 TCP 80 端口数据包（偶尔也有其他普通端口流量）。拦截代理通常出现在公共网络接入点上，作为在允许使用非本地互联网服务之前执行账户订阅的一种手段，以及在企业防火墙内执行网络使用政策。

HTTP 被定义为一个无状态协议，这意味着每个请求报文都可以被独立地理解。许多实现都依赖于 HTTP 的无状态设计，以便重复使用代理连接或在多个服务器上动态地平衡请求。因此，服务器不能假定同一连接上的两个请求是来自同一个用户代理，除非该连接是安全的，并且是特定于该代理的。一些非标准的 HTTP 扩展（例如，[RFC 4559]）已经被认为违反了这一要求，导致了安全和互操作性问题。

## 2.4. 缓存

**缓存(cache)** "是过去响应报文的本地存储，是控制其报文存储、检索和删除的子系统。缓存存储可缓存响应，以减少未来同等请求的响应时间和网络带宽消耗。任何客户或服务器都可以使用缓存，尽管服务器在作为隧道时不能使用缓存。

缓存的作用是，如果链上的一个参与者有一个适用于该请求的缓存响应，那么请求/响应链就会缩短。下面说明了如果 B 拥有 O（通过 C）对一个没有被 UA 或 A 缓存的请求的早期响应的缓存副本，那么产生的链。

```
    >>>         >>>         >>>         >>>
UA =========== A =========== B - - - - - - C - - - - - - O
            <<<             <<<           <<<        <<<
```

如果允许缓存存储响应报文的副本以用于回答后续请求，那么响应就是 "可缓存的"。即使一个响应是可缓冲的，也可能有客户或原服务器对该缓冲响应何时可用于特定请求的额外限制。HTTP 对缓冲行为和可缓冲响应的要求在[RFC 7234]的第 2 节中定义。

在万维网和大型组织内部部署了各种各样的架构和缓存配置。这些包括国家层次的代理缓存以节省跨洋带宽，广播或多播缓存条目的协作系统，用于离线或高延迟环境的预取缓存条目的档案，等等。

## 2.5. 符合性和错误处理

本规范根据 HTTP 通信中的参与者的角色来确定符合性标准。因此，HTTP 要求被置于发送方、接收方、客户、服务器、用户代理、中介、源服务器、代理、网关或缓存上，这取决于什么行为被要求所限制。额外的（社会）要求被放在实现、资源所有者和协议元素注册上，当它们适用于单个通信的范围之外。

动词 "生成" 被用来代替 "发送"，当需求区分了创建协议元素和仅仅将收到的元素转发给下游时。

如果一个实现符合与它在 HTTP 中的角色相关的所有要求，那么它就被认为是符合的。

符合性包括协议元素的语法和语义。发送方 **不得** 生成传达错误含义的协议元素，而该发送方知道这一点。发送方 **不得** 产生不符合相应 ABNF 规则所定义的语法的协议元素。在一个给定的报文中，发送方 **不得** 生成只允许由其他角色的参与者（即发送方对该报文不具有的角色）生成的协议元素或语法替代。

当收到的协议元素被解析时，接收方 **必须** 能够解析适用于接收方角色的任何合理长度的值，并且与相应的 ABNF 规则所定义的语法相匹配。然而，请注意，一些收到的协议元素可能不会被解析。例如，转发报文的中间人可能会将首部字段解析为通用的字段名和字段值成分，但随后转发首部字段，而不进一步解析字段值内部。

HTTP 对它的许多协议元素没有具体的长度限制，因为可能适合的长度会有很大的不同，取决于部署环境和实现的目的。因此，发送方和接收方之间的互操作性取决于对每个协议元素的合理长度的共同期望。此外，在过去 20 年的 HTTP 使用过程中，人们普遍认为某些协议元素的合理长度已经发生了变化，预计未来还会继续变化。

至少，接收方 **必须** 能够解析和处理协议元素的长度，至少与它在其他报文中为这些相同的协议元素产生的值一样长。例如，一个发布非常长的 URI 引用到它自己的资源的初始服务器需要能够在收到请求目标时解析和处理这些相同的引用。

接收方 **必须** 根据本规范为其定义的语义（包括本规范的扩展）来解释收到的协议元素，除非接收方（通过经验或配置）确定发送方不正确地实现这些语义所暗示的内容。例如，如果对 User-Agent 首部字段的检查表明一个特定的实现版本在收到某些内容编码时是失败的，那么一个原点服务器可能会忽略收到的 Accept-Encoding 首部字段的内容。

除非另有说明，接收方 **可以** 尝试从一个无效的结构中恢复一个可用的协议元素。HTTP 没有定义具体的错误处理机制，除非它们对安全有直接影响，因为协议的不同应用需要不同的错误处理策略。例如，网络浏览器可能希望透明地从位置首部字段没有按照 ABNF 解析的响应中恢复，而系统控制客户可能认为任何形式的错误恢复都是危险的。

## 2.6. 协议版本

HTTP 使用"<主要版本号>.<次要版本号>"的编号方案来表示协议的版本。本规范定义了 "1.1" 版本。协议版本作为一个整体表明发送方符合该版本对应的 HTTP 规范中规定的一系列要求。

HTTP 报文的版本由报文第一行的 HTTP-version 字段表示。HTTP-version 是区分大小写的。

```
HTTP-version = HTTP-name "/" DIGIT "." DIGIT
HTTP-name = %x48.54.54.50 ; "HTTP", case-sensitive
```

HTTP 版本号由两位小数组成，以"."（句号或小数点）分开。第一个数字（"主要版本号"）表示 HTTP 报文传输语法，而第二个数字（"次要版本号"）表示该主要版本中最高的次要版本，发送方符合并能够理解该版本，以便将来进行通信。次要版本通告发送方的通信能力，即使发送方只使用协议的向后兼容的子集，从而让接收方知道，更高级的功能可以在响应（由服务器）或未来的请求（由客户）中使用。

当 HTTP/1.1 报文被发送到 HTTP/1.0 接收方[RFC 1945]或版本未知的接收方时，HTTP/1.1 报文的构造是，如果所有较新的功能被忽略，它可以被解释为一个有效的 HTTP/1.0 报文。本规范对一些新特性提出了接收方版本的要求，这样符合要求的发送方将只使用兼容的特性，直到它通过配置或收到的报文确定接收方支持 HTTP/1.1。

一个首部字段的解释在同一主要 HTTP 版本的不同次要版本之间不会改变，尽管接收方在没有这样一个字段时的默认行为可能会改变。除非另有规定，在 HTTP/1.1 中定义的首部字段是为 HTTP/1.x 的所有版本定义的。特别是，所有 HTTP/1.x 的实现都应该实现 Host 和 Connection 首部字段，不管它们是否通告与 HTTP/1.1 一致。

如果新的首部字段定义的语义允许它们被不认识它们的接收方安全地忽略，那么可以在不改变协议版本的情况下引入这些字段。3.2.1 节中讨论了首部字段的可扩展性。

处理 HTTP 报文的中介（即除了作为隧道的中介以外的所有中介）必须在转发的报文中发送自己的 HTTP 版本。换句话说，他们不允许无目的地转发 HTTP 报文的第一行，而不确保该报文中的协议版本与该中介在接收和发送报文时符合的版本一致。在没有重写 HTTP-版本的情况下转发 HTTP 报文，当下游接收方使用报文发送方的版本来确定以后与该发送方的通信可以安全使用哪些功能时，可能会导致通信错误。

客户应该发送一个与客户符合的最高版本相等的请求版本，并且其主要版本不高于服务器所支持的最高版本，如果这是已知的。客户决不能发送它不符合的版本。

如果知道服务器不正确地实现了 HTTP 规范，客户可能会发送一个较低的请求版本，但只有在客户尝试了至少一个正常的请求并从响应状态代码或标题字段（例如，服务器）确定服务器不正确地处理较高的请求版本之后。

服务器应该发送一个等于服务器符合的最高版本的响应版本，该版本的主要版本小于或等于请求中收到的版本。服务器不应该发送它不符合的版本。如果服务器出于任何原因希望拒绝为客户的主要协议版本提供服务，它可以发送一个 505（HTTP Version Not Supported）响应。

如果已知或怀疑客户不正确地实现了 HTTP 规范，并且没有能力正确地处理后来的版本响应，例如，当客户未能正确地解析版本号时，或者当已知中介机构盲目地转发 HTTP-版本时，即使它不符合给定的协议的次要版本，服务器可能会对请求发送 HTTP/1.0 响应。这种协议降级不应该被执行，除非由特定的客户属性触发，例如当一个或多个请求首部字段（如 User-Agent）与已知有错误的客户发送的值唯一匹配时。

HTTP 版本设计的意图是，只有在引入不兼容的报文语法时，才会增加主版本号，而只有在对协议的修改具有增加报文语义或暗示发送方的额外能力的效果时，才会增加次版本号。然而，在[RFC 2068]和[RFC 2616]之间引入的变化中，次要版本没有被递增，这次修订特别避免了对协议的任何此类变化。

当收到一个 HTTP 报文，其主要版本号是接收方实现的，但其次要版本号比接收方实现的要高，接收方应将该报文作为接收方符合的该主要版本中的最高次要版本来处理。接收方可以认为，当发送至尚未表示支持更高版本的接收方时，具有更高次要版本的报文是充分向后兼容的，可以被同一主要版本的任何实现安全地处理。

## 2.7. 统一资源标识符(URI)

统一资源标识符（URI）[RFC 3986]在整个 HTTP 中被用作识别资源的方法（[RFC 7231]第 2 节）。URI 引用被用来定位请求，指示重定向，并定义关系。

URI-reference"、"absolute-URI"、"relative-part"、"scheme"、"authority"、"port"、"host"、"path-abempty"、"segment"、"query "和 "fragment "的定义来自 URI 通用语法。一个 "绝对路径 "规则被定义为可以包含一个非空的路径部分的协议元素。(这个规则与 RFC 3986 的 path-abempty 规则略有不同，后者允许在引用中使用空路径，而 path-absolute 规则则不允许以"//"开首部的路径）。) "部分 URI "规则是为可以包含相对 URI 但不包含片段成分的协议元素而定义的。

```
URI-reference = <URI-reference, see [RFC3986], Section 4.1>
absolute-URI = <absolute-URI, see [RFC3986], Section 4.3>
relative-part = <relative-part, see [RFC3986], Section 4.2>
scheme = <scheme, see [RFC3986], Section 3.1>
authority = <authority, see [RFC3986], Section 3.2>
uri-host = <host, see [RFC3986], Section 3.2.2>
port = <port, see [RFC3986], Section 3.2.3>
path-abempty = <path-abempty, see [RFC3986], Section 3.3>
segment = <segment, see [RFC3986], Section 3.3>
query = <query, see [RFC3986], Section 3.4>
fragment = <fragment, see [RFC3986], Section 3.5>

absolute-path = 1*( "/" segment )
partial-URI = relative-part [ "?" query ]
```

HTTP 中每个允许 URI 引用的协议元素将在其 ABNF 生产中指出该元素是否允许任何形式的引用（URI-reference），只允许绝对形式的 URI（absolute-URI），只允许路径和可选查询部分，或上述的一些组合。除非另有说明，URI 引用是相对于有效请求 URI 解析的（第 5.5 节）。

### 2.7.1. http URI 方案

在此定义 “http” URI 方案，目的是根据其与潜在的 HTTP 源服务器在特定端口上监听 TCP（[RFC 0793]）连接所管理的层次化命名空间的关联来生成标识符。

```
http-URI = "http:" "//" authority path-abempty [ "?" query ] [ "#" fragment ]
```

http "URI 的源服务器是由权威确定的，其中包括一个主机标识和可选的 TCP 端口（[RFC 3986]，第 3.2.2 节）。分层路径部分和可选的查询部分作为该源服务器命名空间中潜在目标资源的标识符。如[RFC 3986]第 3.5 节所定义，可选片段部分允许间接识别二级资源，与 URI 方案无关。

发送方 **不得** 生成带有空主机标识符的 “http” URI。处理这种 URI 引用的接收方必须拒绝它，因为它是无效的。

如果主机标识符被提供为一个 IP 地址，那么源服务器就是该 IP 地址上指定的 TCP 端口的监听器（如果有的话）。如果主机是一个注册的域名，注册的域名是一个间接的标识符，用于域名解析服务，如 DNS，为该源服务器找到一个地址。如果端口子部分是空的或没有给出，TCP 端口默认为 80（为 WWW 服务保留的端口）。

请注意，一个具有特定权限部分的 URI 的存在并不意味着总是有一个 HTTP 服务器在监听该主机和端口的连接。任何人都可以铸造一个 URI。权威部分所决定的是谁有权对针对所识别资源的请求作出权威性的回应。注册名称和 IP 地址的授权性质创建了一个联合名称空间，基于对指定主机和端口的控制，无论是否有 HTTP 服务器存在。与建立授权有关的安全考虑见第 9.1 节。

当 “http” URI 被用于要求访问指定资源的上下文中时，客户可以通过将主机解析为一个 IP 地址，在指定的端口上与该地址建立一个 TCP 连接，并向服务器发送一个包含 URI 识别数据（第 5 节）的 HTTP 请求报文（第 3 节）来尝试访问。如果服务器用非间断的 HTTP 响应报文回应该请求，如[RFC 7231]第 6 节所述，那么该响应被认为是对客户请求的权威性回答。

尽管 HTTP 独立于传输协议，但 “http” 方案是基于 TCP 的服务所特有的，因为名称委托过程依赖于 TCP 来建立权威。基于其他底层连接协议的 HTTP 服务大概会使用不同的 URI 方案来识别，就像 "https" 方案（下文）用于需要端到端安全连接的资源。其他协议也可能被用来提供对 “http” 标识的资源的访问--只有权威接口是特定于 TCP 的。

权威的 URI 通用语法还包括一个废弃的 userinfo 子部分（[RFC 3986]，第 3.2.1 节），用于在 URI 中包括用户认证报文。一些实现将 userinfo 部分用于认证报文的内部配置，例如在命令调用选项、配置文件或书签列表中，尽管这种用法可能会暴露用户标识符或密码。当 “http” URI 引用作为请求目标或首部字段值在报文中生成时，发送方不得生成 userinfo 子部分（及其"@"分隔符）。在使用从不可信任的来源收到的 “http” URI 引用之前，接收方应该解析用户报文，并将其存在视为一个错误；它很可能被用来掩盖权限，以进行网络钓鱼攻击。

### 2.7.2. https URI 方案

在此定义 "https" URI 方案，目的是根据标识符与潜在的 HTTP 起源服务器为 TLS 安全连接监听给定的 TCP 端口所管辖的分层命名空间的关联来铸造标识符（[RFC 5246]）。

上面列出的对 "http" 方案的所有要求也是对 "https" 方案的要求，但如果端口子组件为空或未给出，则 TCP 端口 443 是默认的，而且用户代理必须确保在发送第一个 HTTP 请求之前，通过使用强大的加密技术，端到端确保其与源服务器的连接是安全的。

```
https-URI = "https:" "//" authority path-abempty [ "?" query ] [ "#" fragment ]
```

请注意，"https "URI 方案依赖于 TLS 和 TCP 来建立权威。通过 "https" 方案提供的资源与 "http" 方案没有共同的身份，即使它们的资源标识符显示相同的授权（同一主机监听同一 TCP 端口）。它们是不同的命名空间，被认为是不同的起源服务器。然而，被定义为适用于整个主机域的 HTTP 的扩展，如 Cookie 协议[RFC 6265]，可以允许一个服务设置的报文影响与匹配的主机域组中的其他服务的通信。

[RFC 2818]中定义了对 "https" 标识资源的权威性访问过程。

### 2.7.3. http 和 https URI 的标准化和比较

由于 "http" 和 "https" 方案符合 URI 的通用语法，这种 URI 被标准化，并根据[RFC 3986]第 6 节中定义的算法进行比较，使用上述每种方案的默认值。

如果端口等于某个方案的默认端口，正常形式是省略端口子部分。当不是以绝对形式作为 OPTIONS 请求的请求目标时，空的路径组件等同于"/"的绝对路径，所以正常的形式是提供"/"的路径来代替。方案和主机是不区分大小写的，通常以小写提供；所有其他组件以区分大小写的方式进行比较。除 "保留" 集的字符外，其他字符相当于其百分比编码的八位数：正常形式是不对其进行编码（见[RFC 3986]第 2.1 和 2.2 节）。

例如，以下的 3 个 URI 是相等的：

```
http://example.com:80/˜smith/home.html
http://EXAMPLE.com/%7Esmith/home.html
http://EXAMPLE.com:/%7esmith/home.html
```

# 3. 报文格式

所有的 HTTP/1.1 报文都由一个起始行组成，后面是一串格式类似于互联网报文格式[RFC 5322]的八位数：零个或多个首部字段（统称为 "首部"或 "首部区域"），一个表示首部区域结束的空行，以及一个可选的报文体。

```
HTTP-message = start-line
               *( header-field CRLF )
               CRLF
               [ message-body ]
```

解析 HTTP 报文的正常程序是将起始行读入一个结构，按字段名将每个首部字段读入一个哈希表，直到空行为止，然后使用解析后的数据来确定是否期望有一个报文体。如果显示有报文体，那么它将作为一个流被读取，直到读取到与报文体长度相等的八位数或连接被关闭。

接收方 **必须** 将 HTTP 报文解析为一个八位数的序列，其编码是 US-ASCII[USASCII]的超集。将 HTTP 报文解析为 Unicode 字符流，而不考虑具体的编码。由于字符串处理库处理包含八位数 LF(%x0A)的无效多字节字符序列的方式不同，因此会产生安全漏洞。基于字符串的解析器只能在协议元素从报文中提取后安全地使用，例如在报文解析划定各个字段后，在首部字段-值中使用。

一个 HTTP 报文可以被解析为一个流，用于增量处理或转发到下游。然而，接收方不能依赖部分报文的递增交付，因为有些实现会为了网络效率、安全检查或有效载荷的转换而缓冲或延迟报文的转发。

发送方 **不得** 在起始行和第一个首部字段之间发送空白。接收方如果收到在起始行和第一个首部字段之间的空白，必须拒绝该报文为无效，或者在不进一步处理的情况下消耗每一个以空白为前导的行（即，忽略整个行，以及任何以空白为前导的后续行，直到收到一个正确形成的首部字段或首部区域被终止）。

在请求中出现这样的空白可能是试图欺骗服务器忽略该字段或将其后面的行作为一个新的请求来处理，如果请求链中的其他实现对同一报文有不同的解释，这两种情况都可能导致安全漏洞。同样，在响应中出现这样的空白可能会被一些客户忽略或导致其他客户停止解析。

## 3.1. 起始行

一条 HTTP 报文可以是客户到服务器的请求，也可以是服务器到客户的响应。从语法上讲，这两种类型的报文只在起始行上有区别，起始行可以是 **请求行**（用于请求），也可以是 **状态行**（用于响应），以及确定报文体长度的算法（第 3.3 节）。

在理论上，客户可以接收请求，服务器可以接收响应，通过不同的起始行格式来区分它们，但是，在实践中，服务器被实现为只期望一个请求（响应被解释为一个未知或无效的请求方法），而客户被实现为只期望一个响应。

```
start-line = request-line / status-line
```

### 3.1.1. 请求行

一个请求行以一个方法标记开始，然后是一个空格（SP），请求目标，另一个空格（SP），协议版本，最后以 CRLF 结束。

```
request-line = method SP request-target SP HTTP-version CRLF
```

方法标记表示要对目标资源执行的请求方法。请求方法是区分大小写的。

```
method = token
```

本规范所定义的请求方法可以在[RFC 7231]的第 4 节中找到，同时还有关于 HTTP 方法注册的报文和定义新方法的注意事项。

**请求目标(request-target)** 标识了应用该请求的目标资源，如第 5.3 节所定义。

接收方通常通过分割空白处来解析请求行的组成部分（见第 3.5 节），因为三个组成部分中不允许有空白。不幸的是，一些用户代理未能正确编码或排除超文本引用中的空白，导致这些不允许的字符被发送到请求目标中。

无效请求行的接收方应该以 400(Bad Request)错误或 301(Moved Permanently)重定向来回应，并对请求目标进行正确编码。接收方不应该试图自动更正，然后在没有重定向的情况下处理请求，因为无效的请求行可能是故意制作的，以绕过请求链上的安全过滤器。

如第 2.5 节所述，HTTP 没有对请求行的长度进行预定义的限制。一个服务器如果收到一个比它所实现的任何方法都长的方法，应该用 501(Not Implemented)状态代码来响应。如果服务器收到的请求目标长于它希望解析的任何 URI，则必须以 414(URI Too Long)状态代码进行响应（参见第 6.5.12 节[RFC 7231]）。

在实践中会发现对请求行长度的各种特别限制。建议所有 HTTP 发送方和接收方至少支持 8000 个字节的请求行长度。

### 3.1.2. 状态行

响应报文的第一行是状态行，由协议版本、空格（SP）、状态代码、另一个空格、描述状态代码的可能为空的文本短语组成，并以 CRLF 结束。

```
status-line = HTTP-version SP status-code SP reason-phrase CRLF
```

status-code 部分是一个 3 位数的整数代码，描述了服务器试图理解和满足客户的相应请求的结果。响应报文的其余部分将根据为该状态代码定义的语义来解释。关于状态码的语义，包括状态码的类别（由第一个数字表示）、本规范定义的状态码、定义新状态码的注意事项以及 IANA 注册表，见[RFC 7231]的第 6 节。

```
status-code = 3DIGIT
```

Reason-phrase 部分存在的唯一目的是提供与数字状态码相关的文本描述，这主要是出于对早期互联网应用协议的尊重，这些协议更经常地用于交互式文本客户。客户应该忽略原因短语的内容。

```
reason-phrase = *( HTAB / SP / VCHAR / obs-text )
```

## 3.2. 首部字段

每个首部字段由一个不区分大小写的字段名组成，后面是冒号（":"）、可选的前导空白、字段值和可选的后导空字段名标记将相应的字段值标记为具有该首部字段所定义的语义。例如，在[RFC 7231]第 7.1.1.2 节中，Date 首部字段被定义为包含它所出现的报文的起源时间戳。白。

```
header-field = field-name ":" OWS field-value OWS

field-name = token
field-value = *( field-content / obs-fold )
field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
field-vchar = VCHAR / obs-text

obs-fold = CRLF 1*( SP / HTAB )
           ; obsolete line folding
           ; see Section 3.2.4
```

字段名标记将相应的字段值标记为具有该首部字段所定义的语义。例如，在[RFC 7231]第 7.1.1.2 节中，Date 首部字段被定义为包含它所出现的报文的起源时间戳。

### 3.2.1. 字段扩展性

首部字段是完全可扩展的：对引入新的字段名没有限制，每个字段大概都定义了新的语义，也没有限制在一个给定报文中使用的首部字段的数量。现有的字段在本规范的每个部分和本文档集以外的许多其他规范中都有定义。

新的首部字段可以被定义，当它们被接收方理解时，它们可以覆盖或加强对先前定义的首部字段的解释，定义请求评估的前提条件，或完善响应的含义。

代理 **必须** 转发未识别的首部字段，除非字段名被列在连接首部字段中（第 6.1 节），或者代理被特别配置为阻止或以其他方式转换这些字段。其他接收方 **应该** 忽略未被识别的首部字段。这些要求允许 HTTP 的功能得到增强，而不需要事先更新已部署的中介。

所有定义的首部字段都应该在 IANA 的 "报文首部" 注册表中注册，如[RFC 7231]第 8.3 节中所述。

### 3.2.2. 字段顺序

接收具有不同字段名的首部字段的顺序并不重要。然而，好的做法是先发送包含控制数据的首部字段，如请求中的 Host 和响应中的 Date，这样实现就可以尽早决定何时不处理一个报文。在收到整个请求首部区域之前，服务器不得将请求应用于目标资源，因为后来的首部字段可能包括条件、认证凭证或故意误导的重复首部字段，这将影响请求处理。

发送方 **不得** 在一条报文中生成具有相同字段名的多个首部字段，除非该首部字段的整个字段值被定义为逗号分隔的列表[即#(value)]，或者该首部字段是众所周知的例外（如下所述）。

接收方 **可以** 将具有相同字段名的多个首部字段合并为一个 "字段名：字段值" 对，而不改变报文的语义，方法是将每个后续字段值按顺序附加到合并的字段值上，用逗号分隔。因此，具有相同字段名的首部字段的接收顺序对组合字段值的解释很重要；代理在转发报文时 **不得** 改变这些字段值的顺序。

注意：在实践中，"Set-Cookie" 首部字段（[RFC 6265]）经常在响应报文中出现多次，并且不使用列表语法，违反了上述关于多个同名首部字段的要求。由于它不能被合并成一个字段值，接收方在处理首部字段时应该把 "Set-Cookie" 作为一种特殊情况来处理。(详见[Kri 2001]的附录 A.2.3）。)

### 3.2.3. 空白

本规范使用三种规则来表示线性空白的使用。OWS（可选空白）、RWS（必需空白）和 BWS（"坏"空白）。

OWS 规则用于可能出现零或更多线性空白的八位数。对于为了提高可读性而倾向于选择空白的协议元素，发送方 **应该** 将可选的空白生成为单个 SP；否则，发送方 **不应该** 生成可选的空白，除非在就地报文过滤过程中需要清除无效的或不需要的协议元素。

当至少需要一个线性空白的八位数来分隔字段标记时，就会使用 RWS 规则。发送方 **应该** 将 RWS 生成为单个 SP。

BWS 规则用于语法仅出于历史原因允许可选的空白的情况。发送方 **不应该** 在报文中生成 BWS。接收方 **必须** 在解释协议元素之前解析这种不良的空白并将其删除。

```
OWS = *( SP / HTAB )
      ; optional whitespace
RWS = 1*( SP / HTAB )
      ; required whitespace
BWS = OWS
      ; "bad" whitespace
```

### 3.2.4. 字段解析

报文是用一种通用的算法来解析的，与各个首部字段的名称无关。一个给定的字段值内的内容直到报文解释的后期阶段才会被解析（通常是在报文的整个首部区域被处理之后）。因此，本规范不使用 ABNF 规则来定义每个 "字段名。字段值" 对，就像以前的版本那样。相反，本规范使用根据每个注册的字段名命名的 ABNF 规则，其中该规则定义了该字段对应的字段值的有效语法（即，在字段-值被通用字段分析器从首部区域提取后）。

首部字段名和冒号之间不允许有空白。在过去，对这种空白处理的不同导致了请求路由和响应处理中的安全漏洞。服务器 **必须** 拒绝任何收到的、在首部字段名和冒号之间含有空格的请求报文，其响应代码为 400(Bad Request)。代理 **必须** 在向下游转发报文之前从响应报文中删除任何此类空白。

字段值前面和/或后面可能有可选的空白(OWS)；为了使人类的可读性一致，字段值前面最好有一个 SP。字段值不包括任何前面或后面的空白。在字段值的第一个非空白八位字节之前或在字段值的最后一个非空白八位字节之后出现的 OWS 应该被解析器在从首部字段中提取字段值时排除。

历史上，HTTP 首部的字段值可以通过在每一个额外的行前至少有一个空格或水平制表符（obs-fold）来扩展到多行。除了在 message/http 媒体类型中（第 8.3.1 节），本规范废除了这种折行。发送方 **不得** 生成包括折行的报文（即有任何包含与 obs-fold 规则相匹配的字段值），除非该报文打算在报文/http 媒体类型中打包。

在不在报文/http 容器内的请求报文中收到折行的服务器 **必须** 通过发送 400(Bad Request)来拒绝该报文，最好是用说明来解释折行是不可接受的，或者在解释字段值或将报文转发到下游之前用一个或多个 SP 字节来替换每个收到的折行。

代理或网关如果在不在报文/http 容器内的响应报文中收到废弃的折行，**必须** 丢弃该报文并以 502(Bad Gateway)响应代替它，最好带有解释收到不可接受的折行的表示，或者在解释字段值或向下游转发报文之前用一个或多个 SP 八位字节代替每个收到的废弃的折行。

用户代理如果在不在报文/http 容器内的响应报文中收到 obs-fold，那么在解释字段值之前，**必须** 用一个或多个 SP 八位数替换每个收到的 obs-fold。

历史上，HTTP 允许字段内容采用 ISO-8859-1 字符集[ISO-8859-1]，只通过使用[RFC 2047]编码来支持其他字符集。在实践中，大多数 HTTP 首部字段值只使用 US-ASCII 字符集[USASCII]的一个子集。新定义的首部字段应该将其字段值限制在 US-ASCII 八位数。接收方应该把字段内容（obs-text）中的其他八位字节视为不透明数据。

### 3.2.5. 字段限制

如第 2.5 节所述，HTTP 没有对每个首部字段的长度或首部区域的整体长度做出预定的限制。在实践中，对单个首部字段的长度有各种特别的限制，通常取决于具体的首部字段语义。

一个服务器如果收到的请求首部字段或字段集超过它希望处理的长度，**必须** 以适当的 4xx(Client Error)状态代码来响应。忽略这些首部字段会增加服务器对请求偷渡攻击的脆弱性（第 9.5 节）。

如果字段的语义是可以安全地忽略掉被丢弃的值而不改变报文框架或响应语义，那么客户 **可以** 丢弃或截断收到的大于客户希望处理的首部字段。

### 3.2.6. 字段值部分

大多数 HTTP 首部字段的值都是使用常见的语法组件（token、quoted-string 和 comment）来定义的，并以空格或特定的定界字符分隔。定界符是从标记中不允许的 US-ASCII 视觉字符集中选择的（DQUOTE 和"(),/:;<=>?@[\]{}"）。

```
token = 1*tchar

tchar = "!" / "#" / "$" / "%" / "&" / "’" / "*"
        / "+" / "-" / "." / "^" / "_" / "‘" / "|" / "˜"
        / DIGIT / ALPHA
        ; any VCHAR, except delimiters
```

如果一个文本字符串使用双引号引出，则被解析为一个单值。

```
quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
qdtext = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
obs-text = %x80-FF
```

注释可以包含在一些 HTTP 首部字段中，方法是用圆括号包围注释文本。注释只允许出现在包含 "注释" 的字段中，作为其字段值定义的一部分。

```
comment = "(" *( ctext / quoted-pair / comment ) ")"
ctext = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
```

反斜线八位数("/")可以作为一个单八位数的引号机制在引号字符串和注释结构中使用。处理引号字符串的值的接收方必须处理引号对，就像它被反斜杠后面的八位数取代一样。

```
quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
```

发送方不应该在一个带引号的字符串中产生一个引号对，除非在必要时引用 DQUOTE 和该字符串中出现的反斜杠八位数。发送方不应该在注释中产生一个带引号的对，除非在必要时引用括号["(" 和 ")"]和该注释中出现的反斜杠八位数。

## 3.3. 报文体

HTTP 报文的报文体（如果有的话）被用来承载该请求或响应的有效载荷体。报文体与有效载荷体是相同的，除非应用了传输编码，如第 3.3.1 节中所述。

```
message-body = *OCTET
```

对于请求和响应来说，报文体何时被允许出现在报文中的规则不同。

请求中报文体的存在是由 Content-Length 或 Transfer-Encoding 首部字段来表示的。请求报文框架与方法语义无关，即使该方法没有定义报文体的任何用途。

响应中报文体的存在取决于它所响应的请求方法和响应状态代码（第 3.1.2 节）。对 HEAD 请求方法（[RFC 7231]第 4.3.2 节）的响应从不包括报文体，因为相关的响应首部字段（例如 Transfer-Encoding、Content-Length 等），如果存在的话，只表示如果请求方法是 GET（[RFC 7231]第 4.3.1 节），它们的值会是什么。对 CONNECT 请求方法（[RFC 7231]第 4.3.6 节）的 2xx(Successful)响应切换到隧道模式，而不是有一个报文体。所有 1xx(Informational)、204(No Content)和 304(Not Modified)响应都不包括报文体。所有其他响应都包括一个报文体，尽管该报文体可能是零长度。

### 3.3.1. Transfer-Encoding

Transfer-Encoding 首部字段列出了与已经（或将要）应用于有效载荷体的传输编码序列相对应的传输编码名称，以形成报文体。传输编码的定义见第 4 节。

```
Transfer-Encoding = 1#transfer-coding
```

Transfer-Encoding 类似于 MIME 的 Content-Transfer-Encoding 字段，它被设计为在 7 位传输服务上实现二进制数据的安全传输（[RFC 2045]，第 6 节）。然而，安全传输对于一个 8 位的干净传输协议来说有不同的重点。在 HTTP 的情况下，Transfer-Encoding 主要是为了准确地划分动态生成的有效载荷，并将仅用于传输效率或安全的有效载荷编码与作为所选资源特征的编码区分开。

接收方必须能够解析分块传输编码（第 4.1 节），因为在事先不知道有效载荷体大小的情况下，它在构架报文方面起着关键作用。发送方不得对一个报文体应用分块一次以上（即不允许对已经分块的报文进行分块）。如果除 chunked 以外的任何传输编码被应用于请求有效载荷体，发送方必须应用 chunked 作为最后的传输编码，以确保报文被正确地构架。如果除 chunked 以外的任何传输编码被应用于响应有效载荷体，发送方必须应用 chunked 作为最终传输编码或通过关闭连接来终止报文。

例如：

```
Transfer-Encoding: gzip, chunked
```

表示有效载荷体已经使用 gzip 编码进行了压缩，然后在形成报文体时使用 chunked 编码进行分块。

与 Content-Encoding（[RFC 7231]第 3.1.2.1 节）不同，Transfer-Encoding 是报文的一个属性，而不是表示方法，而且沿着请求/响应链的任何接收方都 **可以** 对收到的传输编码进行解码，或者对报文体应用额外的传输编码，前提是对 Transfer-Encoding 字段值做出相应的改变。关于编码参数的其他信息可以由本规范没有定义的其他首部字段提供。

Transfer-Encoding **可以** 在对 HEAD 请求的响应中或对 GET 请求的 304(Not Modified)响应（[RFC 7232]第 4.1 节）中发送，这两个请求都不包括报文体，以表明如果该请求是无条件的 GET，起源服务器将对报文体应用转移编码。然而，这种指示是不需要的，因为响应链上的任何接收方（包括源服务器）都可以在不需要转移编码时删除它们。

服务器 **不得** 在任何状态代码为 1xx(Informational)或 204(No Content)的响应中发送传输编码首部字段。服务器 **不得** 在对 CONNECT 请求的任何 2xx(Successful)响应中发送 Transfer-Encoding 首部字段（[RFC 7231]的 4.3.6 节）。

Transfer-Encoding 是在 HTTP/1.1 中添加的。一般认为，只支持 HTTP/1.0 的实现将不理解如何处理传输编码的有效载荷。除非客户知道服务器会处理 HTTP/1.1（或更高版本）的请求，否则客户 **不得** 发送包含 Transfer-Encoding 的请求；这种通告可能是以特定的用户配置的形式，或者通过记住先前收到的响应的版本。除非相应的请求表明是 HTTP/1.1（或更高版本），否则服务器 **不得** 发送包含 Transfer-Encoding 的响应。

一个服务器如果收到一个带有它不理解的传输编码的请求报文，**应该** 以 501(Not Implemented)来响应。

### 3.3.2. Content-Length

当报文没有 Transfer-Encoding 首部字段时，Content-Length 首部字段可以为潜在的有效载荷体提供预期的大小，作为一个十进制的字节数。对于包括有效载荷体的报文，Content-Length 字段值提供了确定主体（和报文）结束位置所需的框架信息。对于不包括有效载荷体的报文，Content-Length 表示所选表示的大小（[RFC 7231]的第 3 节）。

```
Content-Length = 1*DIGIT
```

例如：

```
Content-Length: 3495
```

发送方 **不得** 在任何包含 Transfer-Encoding 首部字段的报文中发送 Content-Length 首部字段。

当没有发送 Transfer-Encoding 并且请求方法定义了所包含的有效载荷体的含义时，用户代理 **应该** 在请求报文中发送 Content-Length。例如，通常在 POST 请求中发送 Content-Length 首部字段，即使其值为 0（表示一个空的有效载荷体）。当请求报文不包含有效载荷体，并且方法语义没有预料到有这样一个体时，用户代理 **不应该** 发送 Content-Length 首部字段。

服务器 **可以** 在对 HEAD 请求的响应中发送 Content-Length 首部字段（[RFC 7231]的第 4.3.2 节）；服务器 **不得** 在这种响应中发送 Content-Length，除非它的字段值等于如果同一请求使用 GET 方法时在响应的有效载荷体中发送的十进制数。

服务器 **可以** 在对有条件的 GET 请求（[RFC 7232]第 4.1 节）的 304(Not Modified)响应中发送 Content-Length 首部字段；服务器 **不得** 在这种响应中发送 Content-Length，除非其字段值等于对同一请求的 200(OK)响应的有效载荷体中所发送的十进制数。

服务器 **不得** 在任何状态代码为 1xx(Informational)或 204(No Content)的响应中发送 Content-Length 首部字段。服务器 **不得** 在对 CONNECT 请求的任何 2xx(Successful)响应中发送 Content-Length 首部字段（[RFC 7231]的 4.3.6 节）。

除了上面定义的情况外，在没有 Transfer-Encoding 的情况下，当有效载荷体出现时，源服务器应该发送一个 Content-Length 首部字段。因为在发送完整的首部区域之前，有效载荷体的大小是已知的。这将允许下游接收方测量传输进度，知道什么时候收到的报文是完整的，并有可能为其他请求重新使用连接。

任何大于或等于零的 Content-Length 字段值都是有效的。由于对有效载荷的长度没有预定的限制，接收方必须预计到潜在的大的十进制数字，并防止由于整数转换溢出造成的解析错误（第 9.3 节）。

如果收到的报文有多个 Content-Length 首部字段，其字段值由相同的十进制数值组成，或者有一个 Content-Length 首部字段，其字段值包含一个相同的十进制数值列表（例如。"Content-Length: 42, 42"），表明上游报文处理器生成或合并了重复的 Content-Length 首部字段，那么接收方必须在确定报文正文长度或转发报文之前，以无效的方式拒绝该报文，或者用包含该十进制值的单一有效 Content-Length 字段替换重复的字段值。

注意：HTTP 在报文框架中使用 Content-Length 与 MIME 中使用同一字段有很大不同，在 MIME 中它是一个可选字段，只在 "message/external-body" 媒体类型中使用。

### 3.3.3. 报文体长度

报文体的长度由以下一项决定（按优先顺序）：

1. 任何对 HEAD 请求的响应和任何具有 1xx(Informational)、204(No Content)或 304(Not Modified)状态代码的响应总是由首部字段之后的第一个空行结束，而不管报文中存在哪些首部字段，因此不能包含报文体。
2. 任何对 CONNECT 请求的 2xx（成功）响应意味着连接将在结束首部字段的空行后立即成为隧道。客户 **必须** 忽略在这种报文中收到的任何 Content-Length 或 Transfer-Encoding 首部字段。
3. 如果有一个 Transfer-Encoding 首部字段，并且分块传输编码（第 4.1 节）是最终的编码，报文体的长度是通过读取和解码分块数据来确定的，直到传输编码表明数据已经完成。
  
如果响应中出现了 Transfer-Encoding 首部字段，并且分块传输编码不是最终编码，那么报文主体的长度是通过读取连接来确定的，直到它被服务器关闭。如果请求中存在 Transfer-Encoding 首部字段，并且分块传输编码不是最终编码，则无法可靠地确定报文主体的长度；服务器 **必须** 以 400(Bad Request)状态代码进行响应，然后关闭连接。

如果收到的报文同时带有 Transfer-Encoding 和 Content-Length 首部字段，那么 Transfer-Encoding 将覆盖 Content-Length。这样的报文可能表明试图执行请求偷渡（第 9.5 节）或响应分割（第 9.4 节），应该作为错误处理。发送方 **必须** 在向下游转发这样的报文之前删除收到的 Content-Length 字段。

4. 如果收到的报文没有 Transfer-Encoding，并且具有不同字段值的多个 Content-Length 首部字段，或者具有无效值的单个 Content-Length 首部字段，那么报文的框架是无效的，接收方 **必须** 将其视为不可恢复的错误。如果这是一个请求报文，服务器 **必须** 以 400(Bad Request)状态代码进行响应，然后关闭连接。如果这是由代理收到的响应报文，代理 **必须** 关闭与服务器的连接，丢弃收到的响应，并向客户发送 502(Bad Gateway)响应。如果这是由用户代理收到的响应报文，用户代理 **必须** 关闭与服务器的连接，并丢弃收到的响应。
5. 如果有一个有效的 Content-Length 首部字段，而没有 Transfer-Encoding，它的十进制值定义了预期的报文体长度（八位数）。如果发送方关闭连接或接收方在收到指定的八位数之前超时，接收方 **必须** 认为报文不完整并关闭连接。
6. 如果这是一个请求报文，并且上述情况都不成立，那么报文体长度为零（没有报文体存在）。
7. 否则，这是一个没有声明报文体长度的响应报文，所以报文体长度由服务器关闭连接前收到的八位数决定。

由于没有办法区分一个成功完成的、有封闭限制的报文和一个因网络故障而中断的部分接收的报文，服务器 **应该** 尽可能地生成编码或有长度限制的报文。闭合限制功能的存在主要是为了向后兼容 HTTP/1.0。

服务器 **可以** 通过响应 411(Length Required)来拒绝一个包含报文体但没有内容长度的请求。

除非已经应用了分块传输编码以外的传输编码，否则如果事先知道报文体的长度，发送包含报文体的请求的客户 **应该** 使用有效的 Content-Length 首部字段，而不是分块传输编码，因为一些现有的服务以 411(Length Required)状态代码响应分块传输，即使它们理解分块传输编码。这通常是因为这些服务是通过一个网关实现的，该网关在被调用之前需要一个内容长度，而服务器不能或不愿意在处理之前缓冲整个请求。

如果用户代理不知道服务器将处理 HTTP/1.1（或更高版本）的请求，那么发送包含报文体的请求的用户代理 **必须** 发送一个有效的 Content-Length 首部字段；这种知识可以是特定用户配置的形式，也可以是通过记住先前收到的响应的版本。

如果已经完全收到了对连接上的最后一个请求的最终响应，并且仍然有额外的数据需要读取，那么用户代理 **可以** 丢弃剩余的数据，或者试图确定该数据是否属于先前响应体的一部分，如果先前报文的 Content-Length 值不正确，就会出现这种情况。客户 **不得** 将这种额外的数据作为单独的响应进行处理、缓存或转发，因为这种行为容易导致缓存中毒。

## 3.4. 处理不完整的报文

一个服务器如果收到一个不完整的请求报文，通常是由于一个取消的请求或一个被触发的超时异常，可能会在关闭连接之前发送一个错误响应。

客户如果收到不完整的响应报文，这可能发生在连接被提前关闭的情况下，或者当解码一个所谓的分块传输编码失败时，**必须** 将该报文记录为不完整。对不完整响应的缓存要求在[RFC 7234]的第 3 节中定义。

如果响应在头部分的中间终止（在收到空行之前），并且状态代码可能依赖于头字段来传达响应的全部含义，那么客户不能假定该含义已被传达；客户可能需要重复请求，以确定下一步要采取什么行动。

如果没有收到终止编码的零尺寸块，使用分块传输编码的报文体是不完整的。如果收到的报文体的大小（以八位字节为单位）小于 Content-Length 给出的值，那么使用有效的 Content-Length 的报文是不完整的。一个既没有分块传输编码也没有 Content-Length 的响应因连接的关闭而终止，因此，不管收到的报文体的八位数是多少，只要标题部分被完整地收到，就被认为是完整的。

## 3.5. 报文解析健壮性

Older HTTP/1.0 user agent implementations might send an extra CRLF
after a POST request as a workaround for some early server
applications that failed to read message body content that was not
terminated by a line-ending. An HTTP/1.1 user agent MUST NOT preface
or follow a request with an extra CRLF. If terminating the request
message body with a line-ending is desired, then the user agent MUST
count the terminating CRLF octets as part of the message body length.

In the interest of robustness, a server that is expecting to receive
and parse a request-line SHOULD ignore at least one empty line (CRLF)
received prior to the request-line.

Although the line terminator for the start-line and header fields is
the sequence CRLF, a recipient MAY recognize a single LF as a line
terminator and ignore any preceding CR.

Although the request-line and status-line grammar rules require that
each of the component elements be separated by a single SP octet,
recipients MAY instead parse on whitespace-delimited word boundaries
and, aside from the CRLF terminator, treat any form of whitespace as
the SP separator while ignoring preceding or trailing whitespace;
such whitespace includes one or more of the following octets: SP,
HTAB, VT (%x0B), FF (%x0C), or bare CR. However, lenient parsing can
result in security vulnerabilities if there are multiple recipients
of the message and each has its own unique interpretation of
robustness (see Section 9.5).

When a server listening only for HTTP request messages, or processing
what appears from the start-line to be an HTTP request message,
receives a sequence of octets that does not match the HTTP-message
grammar aside from the robustness exceptions listed above, the server
SHOULD respond with a 400 (Bad Request) response.
