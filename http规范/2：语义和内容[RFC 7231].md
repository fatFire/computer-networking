**目录：**

- [1. 介绍](#1-介绍)
  - [1.1. 符合性和错误处理](#11-符合性和错误处理)
  - [1.2. 语法记号](#12-语法记号)
- [2. 资源](#2-资源)
- [3. 表示](#3-表示)
  - [3.1. 表示元数据](#31-表示元数据)
    - [3.1.1. 处理表示数据](#311-处理表示数据)
      - [3.1.1.1. 媒体类型](#3111-媒体类型)
      - [3.1.1.2. Charset](#3112-charset)
      - [3.1.1.3. 编码和文本缺省](#3113-编码和文本缺省)
      - [3.1.1.4. Multipart 类型](#3114-multipart-类型)
      - [3.1.1.5. Content-Type](#3115-content-type)
    - [3.1.2. 压缩或完整性的编码](#312-压缩或完整性的编码)
      - [3.1.2.1. 内容编码](#3121-内容编码)
      - [3.1.2.2. Content-Encoding](#3122-content-encoding)
    - [3.1.3. 受众语言](#313-受众语言)
      - [3.1.3.1. 语言标签](#3131-语言标签)
      - [3.1.3.2. Content-Language](#3132-content-language)
    - [3.1.4. 识别](#314-识别)
      - [3.1.4.1. 识别一个表示](#3141-识别一个表示)
      - [3.1.4.2. Content-Location](#3142-content-location)
  - [3.2. 表示数据](#32-表示数据)
  - [3.3. 有效载荷语义](#33-有效载荷语义)
  - [3.4. 内容协商](#34-内容协商)
    - [3.4.1. 主动协商](#341-主动协商)
    - [3.4.2. 被动协商](#342-被动协商)
- [4. 请求方法](#4-请求方法)
  - [4.1. 概览](#41-概览)
  - [4.2. 常见方法属性](#42-常见方法属性)
    - [4.2.1. 安全方法](#421-安全方法)
    - [4.2.2. 同效方法](#422-同效方法)
    - [4.2.3. 可缓存方法](#423-可缓存方法)
  - [4.3. 方法定义](#43-方法定义)
    - [4.3.1. GET](#431-get)
    - [4.3.2. HEAD](#432-head)
    - [4.3.3. POST](#433-post)
    - [4.3.4. PUT](#434-put)
    - [4.3.5. DELETE](#435-delete)
    - [4.3.6. CONNETC](#436-connetc)
    - [4.3.7. OPTIONS](#437-options)
    - [4.3.8. TRACE](#438-trace)
- [5. 请求首部字段](#5-请求首部字段)

# 1. 介绍

每个超文本传输协议（HTTP）报文都是一个请求或一个响应。服务器在连接上监听请求，解析收到的每个报文，解释与确定的请求目标有关的报文语义，并以一个或多个响应报文来响应该请求。客户构造请求报文以传达特定的意图，检查收到的响应以查看意图是否被执行，并决定如何解释结果。本文件根据[RFC 7230]中定义的架构，定义了 HTTP/1.1 请求和响应语义。

HTTP 提供了一个与资源交互的统一接口（第 2 节），无论其类型、性质或实现如何，都可以通过操作和传输表示（第 3 节）。

HTTP 语义包括每个请求方法所定义的意图（第 4 节）、可能在请求首部字段中描述的对这些语义的扩展（第 5 节）、表示机器可读响应的状态码的含义（第 6 节），以及可能在响应首部字段中给出的其他控制数据和资源元数据的含义（第 7 节）。

本文还定义了描述接收方如何解释有效载荷的表示元数据、可能影响内容选择的请求首部字段，以及统称为 "内容协商" 的各种选择算法（第 3.4 节）。

## 1.1. 符合性和错误处理

本文档中的关键词 "必须"、"不得"、"需要"、"应当"、"不应当"、"应该"、"不应该"、"推荐"、"可以" 和 "可选" 应按照[RFC 2119]中的描述进行解释。

有关错误处理的符合性标准和注意事项在[RFC 7230] 第 2.5 节中定义。

## 1.2. 语法记号

本规范使用[RFC 5234]的 Augmented Backus-Naur Form（ABNF）符号，并在[RFC 7230]的第 7 节中定义了一个列表扩展，允许使用'#'操作符（类似于'\*'操作符表示重复的方式）紧凑地定义逗号分隔的列表。附录 C 描述了从其他文件中导入的规则。附录 D 显示了收集到的语法，其中所有的列表操作符都扩展为标准的 ABNF 符号。

本规范使用术语 "字符"、"字符编码方案"、"字符集 "和 "协议元素"，它们在[RFC 6365]中被定义。

# 2. 资源

一个 HTTP 请求的目标被称为 "资源"。HTTP 并不限制资源的性质；它只是定义了一个可能被用来与资源交互的接口。每个资源都由一个统一资源标识符（URI）来识别，如[RFC 7230]第 2.7 节所述。

当客户构建 HTTP/1.1 请求报文时，它以各种形式之一发送目标 URI，如（[RFC 7230]第 5.3 节）所定义。当收到请求时，服务器为目标资源重构一个有效的请求 URI（[RFC 7230]第 5.5 节）。

HTTP 的一个设计目标是将资源识别与请求语义分开，这一点通过将请求语义归入请求方法（第 4 节）和一些修改请求的首部字段（第 5 节）而得以实现。如第 4.2.1 节所述，如果方法语义与 URI 本身所隐含的任何语义之间存在冲突，则方法语义优先。

# 3. 表示

考虑到资源可以是任何东西，而 HTTP 提供的统一接口类似于一个窗口，通过这个窗口，人们只能通过与另一边的一些独立行为者的报文通信来观察和处理这样的东西，因此需要一个抽象来表示（"代替"）该东西在我们通信中的当前或期望状态。这种抽象被称为表示[REST]。

就 HTTP 而言，"表示" 是指旨在反映特定资源的过去、当前或期望状态的信息，其格式可以很容易地通过协议进行通信，并由一组表示元数据和可能无限制的表示数据流组成。

一个源服务器可能被提供或能够生成多个表示，每个表示都旨在反映目标资源的当前状态。在这种情况下，源服务器会使用一些算法来选择其中一个最适用于特定请求的表示，通常是基于内容协商。这种 "选定的表示" 被用来提供数据和元数据，以评估有条件的请求[RFC 7232]，并为 GET 的 200(OK)和 304(Not Modified)响应构建有效载荷（第 4.3.1 节）。

## 3.1. 表示元数据

表示首部字段提供关于表示的元数据。当一个报文包括一个有效载荷体时，表示首部字段描述了如何解释有效载荷体中包含的表示数据。在对 HEAD 请求的响应中，表示首部字段描述了如果同一请求是 GET，就会被包含在有效载荷体中的表示数据。

下面的首部字段传达了表示元数据：

| 字段名           | 定义在     |
| ---------------- | ---------- |
| Content-Type     | 3.1.1.5 节 |
| Content-Encoding | 3.1.2.2 节 |
| Content-Language | 3.1.3.2 节 |
| Content-Location | 3.1.4.2 节 |

### 3.1.1. 处理表示数据

#### 3.1.1.1. 媒体类型

HTTP 在 Content-Type（第 3.1.1.5 节）和 Accept（第 5.3.2 节）首部字段中使用 Internet 媒体类型(media-type)[RFC 2046]，以便提供开放和可扩展的数据类型和类型协商。媒体类型既定义了数据格式，也定义了各种处理模式：如何根据接收数据的各个环境来处理这些数据。

```
media-type = type "/" subtype *( OWS ";" OWS parameter )
type = token
subtype = token
```

类型/子类型后面 **可以** 跟上名称=值对形式的参数。

```
parameter = token "=" ( token / quoted-string )
```

类型、子类型和参数名称标记是不区分大小写的。参数值可能区分大小写，也可能不区分，这取决于参数名称的语义。一个参数的存在或不存在对媒体类型的处理可能是重要的，这取决于它在媒体类型注册表中的定义。

匹配标记产生式的参数值可以作为标记或在引号字符串中传输。带引号和不带引号的值是等价的。例如，下面的例子都是等价的，但为了一致性，首选第一个例子：

```
text/html;charset=utf-8
text/html;charset=UTF-8
Text/HTML;Charset="utf-8"
text/html; charset="utf-8"
```

Internet 媒体类型应该根据[BCP13]中定义的程序向 IANA 注册。

注意：与其他首部字段中的一些类似结构不同，媒体类型参数不允许在"="字符周围有空白（甚至是 "坏"空白）。

#### 3.1.1.2. Charset

HTTP 使用字符集名称来表示或协商文本表示的字符编码方案[RFC 6365]。一个字符集由一个不区分大小写的标记来识别。

```
charset = token
```

根据[RFC 2978]中定义的程序，字符集名称应该在 IANA "字符集"注册表（<http://www.iana.org/assignments/character-sets>）中注册。

#### 3.1.1.3. 编码和文本缺省

Internet 媒体类型被注册为标准形式，以便在具有不同本地编码格式的系统之间实现互操作。由于多用途 Internet 邮件扩展（MIME）[RFC 2045]所描述的许多相同原因，通过 HTTP 选择或传输的表示应该是典型的形式。然而，电子邮件部署的性能特征（即存储和转发报文给对等人）与 HTTP 和 Web（基于服务器的信息服务）的共同特征有很大的不同。此外，MIME 为了与旧的邮件传输协议兼容而做出的限制并不适用于 HTTP（见附录 A）。

MIME 的规范形式要求 "文本" 类型的媒体子类型使用 CRLF 作为文本换行符。HTTP 允许用普通的 CR 或 LF 单独代表换行符来传输文本媒体，当这种换行符在整个表示中是一致的。一个 HTTP 发送方 **可以** 生成，而接收方 **必须** 能够解析由 CRLF、裸 CR 或裸 LF 组成的文本媒体中的换行符。此外，HTTP 中的文本媒体并不局限于使用八位数 13 和 10 的 CR 和 LF 的字符集。这种关于换行的灵活性只适用于被指定为 "文本" 媒体类型的表示中的文本；它不适用于 "multipart" 类型或有效载荷主体之外的 HTTP 元素（例如，首部字段）。

如果一个表现形式被编码为内容编码，那么底层数据在被编码之前就应该是上述定义的形式。

#### 3.1.1.4. Multipart 类型

MIME 提供了许多 "multipart"类型：在一个单一的报文体中封装一个或多个表现形式。所有 multipart 类型共享一个共同的语法，如[RFC 2046]第 5.1.1 节所定义的，并包括一个边界参数作为媒体类型值的一部分。报文体本身是一个协议元素；发送方必须只生成 CRLF 来表示报文体之间的换行。

HTTP 报文分帧不使用 multipart 边界作为报文体长度的指标，尽管它可能被生成或处理有效载荷的实现所使用。例如，"multipart/form-data" 类型通常用于在请求中携带表单数据，如[RFC 2388]所述，而 "multipart/byteranges "类型则由本规范定义，用于一些 206(Partial Content)响应[RFC 7233]。

#### 3.1.1.5. Content-Type

"Content-Type" 首部字段表示相关表示的媒体类型：要么是包含在报文有效载荷中的表示，要么是由报文语义决定的选定表示。所指示的媒体类型既定义了数据格式，也定义了在接收到的报文语义范围内，在任何由 Content-Encoding 指示的内容编码被解码之后，数据打算如何被接收方处理。

```
Content-Type = media-type
```

媒体类型在第 3.1.1.1 节中定义。该字段的一个例子是

```http
Content-Type: text/html; charset=ISO-8859-4
```

生成包含有效载荷体的报文的发送方 **应该** 在该报文中生成一个 Content-Type 首部字段，除非发送方不知道所附表示的预期媒体类型。如果不存在 Content-Type 首部字段，接收方 **可以** 假定媒体类型为 "application/octet-stream"（[RFC 2046]，第 4.5.1 节）或检查数据以确定其类型。

在实践中，资源所有者并不总是正确地配置他们的源服务器，以便为给定的表示提供正确的内容类型，结果是一些客户会检查有效载荷的内容并覆盖指定的类型。这样做的客户有可能得出不正确的结论，这可能会暴露出额外的安全风险（例如，"特权升级"）。此外，不可能通过检查数据格式来确定发送方的意图：许多数据格式与多种媒体类型相匹配，只是在处理语义方面有所不同。我们鼓励实施者在使用这种 "内容嗅探" 时提供一种禁用的方法。

### 3.1.2. 压缩或完整性的编码

#### 3.1.2.1. 内容编码

内容编码(content-coding)值表示已经或可以应用于一个表示的编码转换。内容编码主要是用来让一个代表被压缩或以其他方式进行有用的转换，而不会失去其基础媒体类型的身份和信息的损失。通常情况下，表示以编码形式存储，直接传输，并只由最终的接收方解码。

```
content-coding = token
```

所有的内容编码值都是不区分大小写的，并且应该在 "HTTP 内容编码注册" 中注册，如第 8.4 节所定义。它们被用于 Accept-Encoding（第 5.3.4 节）和 Content-Encoding（第 3.1.2.2 节）首部字段。

本规范定义了以下内容编码值：

```
compress (and x-compress): See Section 4.2.1 of [RFC7230].
deflate: See Section 4.2.2 of [RFC7230].
gzip (and x-gzip): See Section 4.2.3 of [RFC7230].
```

#### 3.1.2.2. Content-Encoding

"Content-Encoding"首部字段表明，除了媒体类型中固有的内容编码外，还有哪些内容编码被应用到表示中，因此，为了获得 Content-Type 首部字段所指的媒体类型中的数据，必须应用哪些解码机制。内容编码主要是用来允许对表示的数据进行压缩而不失去其基础媒体类型的特性。

```
Content-Encoding = 1#content-coding
```

其使用的一个例子是：

```http
Content-Encoding: gzip
```

如果一个或多个编码被应用于一个表示，应用这些编码的发送方 **必须** 生成一个 Content-Encoding 首部字段，按照应用的顺序列出内容编码。关于编码参数的其他信息可以由本规范没有定义的其他首部字段提供。

与 Transfer-Encoding（[RFC 7230]第 3.3.1 节）不同，Content-Encoding 中列出的编码是表示的一个特征；表示是以编码形式定义的，所有其他关于表示的元数据都是关于编码形式的，除非在元数据定义中另外指出。通常情况下，该表示只在渲染或类似的使用之前被解码。

如果媒体类型包括一个固有的编码，例如一个总是被压缩的数据格式，那么这个编码将不会在 Content-Encoding 中重述，即使它恰好与其中一个内容编码的算法相同。这样的内容编码只有在由于某种奇怪的原因，它被第二次应用来形成表示时才会被列出。同样，一个源服务器 **可以** 选择将相同的数据发布为多种表示，而这些表示的不同之处仅在于编码是否被定义为内容类型或内容编码的一部分，因为一些用户代理在处理每个响应时会有不同的行为（例如，打开一个 "保存为... "对话框，而不是自动解压和渲染内容）。

如果请求报文中的某个表示具有不可接受的内容编码，源服务器 **可以** 用 415(Unsupported Media Type)的状态码进行响应。

### 3.1.3. 受众语言

#### 3.1.3.1. 语言标签

按照[RFC 5646]的定义，语言标签(language-tag)是指人类为了向其他人类传递信息而说、写或以其他方式传达的自然语言。计算机语言被明确地排除在外。

HTTP 在 Accept-Language 和 Content-Language 首部字段中使用语言标签。Accept-Language 使用第 5.3.5 节中定义的更广泛的语言范围产生式，而 Content-Language 使用下面定义的语言标签产生式：

```
language-tag = <Language-Tag, 见 [RFC 5646], 2.1节>
```

一个语言标签是由一个或多个不区分大小写的子标签组成的序列，每个子标签由一个连字符（"-"，%x2D）分隔。在大多数情况下，一个语言标签由一个主要的语言子标签组成，它确定了一个广泛的相关语言家族（例如，"en"=英语），后面可以选择一系列子标签，以细化或缩小该语言的范围（例如，"en-CA"=在加拿大传播的英语类型）。语言标签中不允许有空格。标签的例子包括：

```http
fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
```

更多信息见[RFC 5646]。

#### 3.1.3.2. Content-Language

"Content-Language" 首部字段描述了该表示的预期受众的自然语言。请注意，这可能不等同于表示中使用的所有语言。

```
Content-Language = 1#language-tag
```

语言标签的定义见第 3.1.3.1 节。Content-Language 的主要目的是允许用户根据自己喜欢的语言来识别和区分表示。因此，如果内容只为懂丹麦语的读者准备，适当的字段是

```http
Content-Language: da
```

如果没有指定 Content-Language，默认为该内容是为所有语言的受众准备的。这可能意味着发送方不认为它是针对任何自然语言的，或者发送方不知道它是针对哪种语言的。

对于面向多种受众的内容，**可以** 列出多种语言。例如，"怀唐伊条约" 的演绎，同时以毛利语和英语的原始版本呈现，将要求

```http
Content-Language: mi, en
```

然而，仅仅因为一种表示中存在多种语言，并不意味着它是为多种语言的受众准备的。一个例子是初学者的语言启蒙读物，如 "拉丁语第一课"，它显然是为了给懂英语的读者使用。在这种情况下，"Content-Language" 应该只包括 "en"。

Content-Language **可以** 适用于任何媒体类型--它不限于文本文件。

### 3.1.4. 识别

#### 3.1.4.1. 识别一个表示

当一个完整的或部分的表示被传输到一个报文有效载荷中时，通常希望发送方能提供或接收方能确定与该表示相对应的资源的标识符。

对于一个请求报文：

- 如果请求有一个 Content-Location 首部字段，那么发送方就断言有效载荷是 Content-Location 字段值所确定的资源的表示。然而，这样的断言不能被信任，除非它能被其他方式验证（不是由本规范定义）。该信息对修订历史链接可能仍然有用。

- 否则，有效载荷将无法识别。

对于响应报文，按顺序应用以下规则，直到找到一个匹配的信息：

1. 如果请求方法是 GET 或 HEAD，并且响应状态码是 200(OK)、204(No Content)、206(Partial Content)或 304(Not Modified)，则有效载荷是由有效请求 URI（[RFC 7230]第 5.5 节）标识的资源的表示。

2. 如果请求方法是 GET 或 HEAD，并且响应状态码是 203(Non-Authoritative Information)，则有效载荷是由中介提供的目标资源的潜在修改或增强表示。

3. 如果响应有一个 Content-Location 首部字段，并且其字段值是对与有效请求 URI 相同的 URI 的引用，则有效载荷是有效请求 URI 所标识的资源的表示。

4. 如果响应有一个 Content-Location 首部字段，其字段值是对不同于有效请求 URI 的 URI 的引用，那么发送方断言有效载荷是 Content-Location 字段值所确定的资源的表示。然而，这样的断言不能被信任，除非它能被其他方式验证（不是由本规范定义）。

5. 否则，有效载荷将无法识别。

#### 3.1.4.2. Content-Location

"Content-Location" 首部字段引用了一个 URI，该 URI 可被用作与本报文有效载荷中的表示相对应的特定资源的标识符。换句话说，如果人们在本报文产生时对这个 URI 执行一个 GET 请求，那么一个 200(OK)的响应将包含与本报文中作为有效载荷的相同表示。

```
Content-Location = absolute-URI / partial-URI
```

Content-Location 值不是有效请求 URI 的替代物（[RFC 7230]第 5.5 节）。它是表示元数据。它的语法和语义与[RFC2557]第 4 节中为 MIME 主体部分定义的同名首部字段相同。然而，它在 HTTP 报文中的出现对 HTTP 接收方有一些特殊的影响。

如果 Content-Location 包含在 2xx(Successful)响应报文中，并且其值（在转换为绝对形式后）指向与有效请求 URI 相同的 URI，那么接收方可以认为有效载荷是该资源在报文发起日期所示时间的当前表示。对于 GET（第 4.3.1 节）或 HEAD（第 4.3.2 节）请求，这与服务器没有提供 Content-Location 时的默认语义相同。对于像 PUT（第 4.3.4 节）或 POST（第 4.3.3 节）这样的状态改变请求，它意味着服务器的响应包含该资源的新表示，从而将其与可能只报告动作的表示区分开来（例如，"它成功了！"）。这允许编写应用程序更新他们的本地副本，而不需要后续的 GET 请求。

如果 Content-Location 包含在 2xx(Successful)响应报文中，并且其字段值指的是与有效请求 URI 不同的 URI，那么源服务器声称该 URI 是对应于所附表示的不同资源的标识。只有当两个标识符共享相同的资源所有者时，这样的声称才是可信的，而这是无法通过 HTTP 程序化地确定的。

- 对于对 GET 或 HEAD 请求的响应，这表明有效的请求 URI 指的是要进行内容协商的资源，而 Content-Location 字段值是所选表示的一个更具体的标识。

- 对于状态改变方法的 201(Created)响应，与 Location 字段值相同的 Content-Location 字段值表明该有效载荷是新创建资源的当前表示。

- 否则，这样的 Content-Location 表明该有效载荷是报告所请求的行动的状态的表示，并且相同的报告可以在给定的 URI 上获得（供将来用 GET 访问）。给定的 URI 上可以得到同样的报告（以便将来通过 GET 访问）。例如，通过 POST 请求进行的购买交易可能包括一个收据文件，作为 200（OK）响应的有效载荷；Content-Location 字段值提供了一个标识符，以便在将来检索该相同收据的副本。

在请求报文中发送 Content-Location 的用户代理说明它的值是指用户代理最初获得所附表示的内容的地方（在该用户代理进行任何修改之前）。换句话说，用户代理正在提供一个回溯链接到原始表示的来源。

在请求报文中收到 Content-Location 字段的源服务 **必须** 将该信息视为临时的请求上下文，而不是作为元数据被逐字保存为表示的一部分。源服务器 **可以** 使用该上下文来指导处理请求或将其保存为其他用途，例如在源链接或版本元数据中。然而，源服务器 **不得** 使用这种上下文信息来改变请求的语义。

例如，如果客户对协商的资源提出 PUT 请求，并且源服务器接受该 PUT（没有重定向），那么该资源的新状态应该与该 PUT 中提供的一个表示一致；Content-Location 不能被用作反向内容选择标识符的形式来更新协商的表示之一。如果用户代理想要后一种语义，它将直接对 Content-Location URI 应用 PUT。

## 3.2. 表示数据

与 HTTP 报文相关的表示数据要么作为报文的有效载荷体提供，要么由报文语义和有效请求 URI 提及。表示数据的格式和编码是由表示元数据首部字段定义的。

表示数据的数据类型通过首部字段 Content-Type 和 Content-Encoding 确定。这些定义了一个两层的、有序的编码模型：

```
representation-data := Content-Encoding( Content-Type( bits ) )
```

## 3.3. 有效载荷语义

一些 HTTP 报文作为报文的 "有效载荷" 传输完整或部分表示。在某些情况下，有效载荷可能只包含相关表示的首部字段（例如，对 HEAD 的响应）或只包含表示数据的某些部分（例如，206(Partial Content) 状态码）。

请求中的有效载荷的目的由方法语义定义。例如，PUT 请求（第 4.3.4 节）的有效载荷中的表示代表目标资源的期望状态，如果请求被成功应用，而 POST 请求（第 4.3.3 节）的有效载荷中的表示代表目标资源要处理的信息。

在响应中，有效载荷的目的是由请求方法和响应状态码定义的。例如，对 GET（第 4.3.1 节）的 200(OK)响应的有效载荷代表目标资源的当前状态，这是在报文发起日期（第 7.1.1.2 节）时观察到的，而对 POST 的响应中相同状态码的有效载荷可能代表处理结果或应用处理后目标资源的新状态。带有错误状态码的响应报文通常包含代表错误状态的有效载荷，例如它描述了错误状态以及建议采取哪些下一步措施来解决它。

具体描述有效载荷而不是相关表示的首部字段被称为 "有效载荷首部字段"。由于对消息报文的影响，本规范的其他部分定义了有效载荷首部字段。

| 首部字段名        | 定义在                |
| ----------------- | --------------------- |
| Content-Length    | [RFC 7230]的 3.3.2 节 |
| Content-Range     | [RFC 7233]的 4.2 节   |
| Trailer           | [RFC 7230]的 4.4 节   |
| Transfer-Encoding | [RFC 7230]的 3.3.1 节 |

## 3.4. 内容协商

当响应传达有效载荷信息时，无论是表示成功还是错误，源服务器通常有不同的方式来表示该信息；例如，以不同的格式、语言或编码。同样，不同的用户或用户代理可能有不同的能力、特点或偏好，这可能会影响到在这些可用的表示方式中，哪种表示方式是最好的传递。出于这个原因，HTTP 提供了内容协商的机制。

本规范定义了两种可以在协议中显示的内容协商模式。"主动式"，即服务器根据用户代理声明的偏好来选择表示，以及 "被动式"协商，即服务器提供一个表示的列表供用户代理选择。内容协商的其他模式包括 "有条件的内容"，其中表示由多个部分组成，根据用户代理的参数有选择地呈现；"主动的内容"，其中表示包含一个脚本，根据用户代理的特征提出额外的（更具体的）请求；以及 "透明的内容协商"（[RFC 2295]），其中内容选择由一个中介执行。这些模式并不是相互排斥的，而且每一种模式在适用性和实用性方面都有取舍。

请注意，在所有情况下，HTTP 都不知道资源的语义。在不同的时间和不同的内容协商维度上，起源服务器对请求的响应的一致性，以及因此在不同时间观察到的资源表现的 "同一性"，完全由选择或产生这些响应的实体或算法决定。HTTP 没有注意到幕后的人。

### 3.4.1. 主动协商

当用户代理在请求中发送内容协商偏好以鼓励位于服务器上的算法选择首选表示时，这被称为主动协商（又称服务器驱动的协商）。选择是基于响应的可用表示（它可能变化的维度，如语言、内容编码等）与请求中提供的各种信息相比较，包括第 5.3 节的显式协商字段和隐式特征，如客户的网络地址或用户代理字段的一部分。

当从可用的表示中进行选择的算法难以向用户代理描述时，或者当服务器希望将其 "最佳猜测" 与第一个响应一起发送给用户代理时，主动协商是有利的（如果 "最佳猜测" 对用户来说足够好，希望避免后续请求的往返延迟）。为了改进服务器的猜测，用户代理可能会发送描述其偏好的请求首部字段。

主动协商有严重的缺点：

- 服务器不可能准确地确定什么对任何给定的用户是 "最好的"，因为这需要完全了解用户代理的能力和响应的预期用途（例如，用户想在屏幕上查看还是在纸上打印？

- 让用户代理在每个请求中描述它的能力可能是非常低效的（考虑到只有一小部分的响应有多种表现形式），并且对用户的隐私有潜在的风险。

- 它使源服务器的实现和生成对请求的响应的算法复杂化；而且。

- 它限制了共享缓存的响应的可重复使用性。

用户代理不能依赖主动协商的偏好得到一致的尊重，因为源服务器可能没有为请求的资源实施主动协商，或者可能决定发送不符合用户代理偏好的响应比发送 406(Not Acceptable)响应更好。

Vary 首部字段（第 7.1.4 节）通常在受主动协商的响应中发送，以表明请求报文的哪些部分被用于选择算法。

### 3.4.2. 被动协商

通过被动协商（又称代理驱动的协商），用户代理在收到来自源服务器的初始响应后执行最佳响应表示的选择（无论状态码如何），该响应包含替代表示的资源列表。如果用户代理对初始响应表示不满意，它可以对一个或多个替代资源执行 GET 请求，这些替代资源是根据包含在列表中的元数据选择的，以获得该响应的不同表示形式。替代资源的选择可以由用户代理自动执行，或者由用户从生成的（可能是超文本）菜单中手动选择。

请注意，上面提到的是响应的表示方法，一般来说，不是资源的表示方法。只有当提供这些替代方案的响应具有作为目标资源的表示的语义（例如，对 GET 请求的 200（OK）响应）或具有为目标资源提供替代表示的链接的语义（例如，对 GET 请求的 300(Multiple Choices)响应），替代表示才被视为目标资源的表示。

服务器 **可以** 选择不发送初始表示，而不是备选方案的列表，从而表明用户代理的被动协商是首选。例如，在具有 300(Multiple Choices)和 406(Not Acceptable)状态码的响应中列出的备选方案包括关于可用的表示方法的信息，以便用户或用户代理可以通过做出选择做出反应。

当响应会在常用的维度（如类型、语言或编码）上发生变化时，当起源服务器无法通过检查请求来确定用户代理的能力时，以及通常当公共缓存被用来分配服务器负载并减少网络使用时，被动协商是有利的。

被动协商有以下缺点：向用户代理传输替代方案的列表，如果在头部分传输，会降低用户感知的延迟，并且需要第二次请求来获得替代的表示。此外，本规范没有定义支持自动选择的机制，尽管它并不妨碍将这种机制作为一种扩展来开发。

# 4. 请求方法

## 4.1. 概览

请求方法标记是请求语义的主要来源；它指出了客户提出这个请求的目的，以及客户对成功结果的期望。

请求方法的语义可以通过一些首部字段的语义在请求中出现时进一步专业化（第 5 节），如果这些额外的语义与方法不冲突的话。例如，客户可以发送有条件的请求首部字段（第 5.2 节），以使请求的动作以目标资源的当前状态为条件（[RFC 7232]）。

```
method = token
```

HTTP 最初被设计为可用作分布式对象系统的接口。请求方法被设想为在目标资源上应用语义，就像在确定的对象上调用定义的方法来应用语义一样。方法标记是区分大小写的，因为它可能被用作通往基于对象的系统的网关，而该系统的方法名称是区分大小写的。

与分布式对象不同，HTTP 中的标准化请求方法不是针对特定资源的，因为统一的接口在基于网络的系统中提供了更好的可见性和重用性[REST]。一旦被定义，标准化方法在应用于任何资源时都应该具有相同的语义，尽管每个资源自己决定这些语义是否被实现或允许。

本规范定义了一些 HTTP 中常用的标准化方法，如下表所示。按照惯例，标准化的方法是以全大写的 US-ASCII 字母来定义的。

| 方法    | 描述                                         | 章节  |
| ------- | -------------------------------------------- | ----- |
| GET     | 传输目标资源的当前表示。                     | 4.3.1 |
| HEAD    | 与 GET 相同，但只传输状态行和首部区域。      | 4.3.2 |
| POST    | 对请求有效载荷进行特定资源处理。             | 4.3.3 |
| PUT     | 用请求的有效载荷替换目标资源的所有当前表示。 | 4.3.4 |
| DELETE  | 移除目标资源的所有当前表示。                 | 4.3.5 |
| CONNECT | 建立一个隧道到目标资源所识别的服务器。       | 4.3.6 |
| OPTIONS | 描述目标资源的通信选项。                     | 4.3.7 |
| TRACE   | 沿着通往目标资源的路径进行报文回环测试。     | 4.3.8 |

所有通用服务器都必须支持 GET 和 HEAD 方法。所有其他的方法都是 **可选的**。

本规范范围之外的其他方法已经被标准化，以便在 HTTP 中使用。所有这些方法都应该在 IANA 维护的 "超文本传输协议（HTTP）方法注册表" 中注册，如第 8.1 节所定义。

目标资源所允许的方法集可以在 Allow 首部字段中列出（第 7.4.1 节）。然而，允许的方法集可以动态地改变。当收到未被源服务器识别或未被源服务器实现的请求方法时，源服务器应该以 501(Not Implemented)状态码进行响应。当接收到源服务器已知但目标资源不允许的请求方法时，源服务器应以 405(Method Not Allowed)状态码进行响应。

## 4.2. 常见方法属性

### 4.2.1. 安全方法

如果请求方法所定义的语义基本上是只读的，则被认为是 "安全的"；也就是说，客户不要求，也不期望，由于对目标资源应用安全方法而在源服务器上产生任何状态变化。同样地，合理地使用安全方法也不会对源服务器造成任何伤害、财产损失或不寻常的负担。

这个安全方法的定义并不妨碍实现包括有潜在危害的行为，不完全是只读的，或者在调用安全方法时引起副作用。然而，重要的是，客户没有要求这种额外的行为，不能对其负责。例如，大多数服务器在每个响应完成时都会将请求信息附加到访问日志文件中，不管是什么方法，这被认为是安全的，即使日志存储可能会变满并使服务器崩溃。同样，通过选择网络上的广告发起的安全请求，往往会产生向广告账户收费的副作用。

在本规范定义的请求方法中，GET、HEAD、OPTIONS 和 TRACE 方法被定义为安全的。

区分安全和不安全方法的目的是允许自动检索过程（爬虫）和缓存性能优化（预取）工作而不用担心造成伤害。此外，它允许用户代理在处理可能不受信任的内容时对不安全方法的自动使用进行适当的限制。

当向用户展示潜在的行动时，用户代理 **应该** 区分安全和不安全的方法，这样用户就可以在请求之前了解不安全的行动。

当一个资源被构造成有效请求 URI 中的参数具有选择动作的效果时，资源所有者有责任确保该动作与请求方法的语义一致。例如，基于网络的内容编辑软件通常在查询参数中使用动作，如 "page?do=delete"。如果这种资源的目的是执行不安全的动作，那么当使用安全请求方法访问它时，资源所有者 **必须** 禁用或不允许该动作。如果不这样做，当自动程序为了维护链接、预取、建立搜索索引等而对每个 URI 引用执行 GET 时，将导致不幸的副作用。

### 4.2.2. 同效方法

如果使用一个请求方法的多个相同的请求对服务器的影响与单个请求的影响相同，那么该请求方法被认为是 "同效的"。在本规范所定义的请求方法中，PUT、DELETE 和 safe 请求方法是同效的。

和安全的定义一样，同效属性只适用于用户请求的内容；服务器可以自由地单独记录每个请求，保留修订控制历史，或者为每个同位素请求实现其他非同位素的副作用。

idempotent 方法的区别在于，如果在客户能够读取服务器的响应之前发生通信故障，请求可以自动重复。例如，如果一个客户发送了一个 PUT 请求，而底层连接在收到任何响应之前就被关闭了，那么客户可以建立一个新的连接并重试该同效请求。它知道重复请求将产生相同的预期效果，即使最初的请求成功了，尽管响应可能不同。

### 4.2.3. 可缓存方法

请求方法可以被定义为 "可缓存"，以表明对它们的响应允许被存储以便将来重复使用；具体要求见[RFC 7234] 。一般来说，不依赖于当前或权威响应的安全方法被定义为可缓存；本规范将 GET、HEAD 和 POST 定义为可缓存，尽管绝大多数的缓存实现只支持 GET 和 HEAD。

## 4.3. 方法定义

### 4.3.1. GET

GET方法要求为目标资源传输当前选定的表示。GET是信息检索的主要机制，也是几乎所有性能优化的重点。因此，当人们谈到通过HTTP检索一些可识别的信息时，他们一般指的是提出一个GET请求。

我们很容易把资源标识符看作是远程文件系统的路径名，而把表示看作是这种文件内容的副本。事实上，许多资源就是这样实现的（相关的安全考虑见第9.1节）。然而，在实践中并没有这种限制。一个资源的HTTP接口同样有可能被实现为一棵内容对象的树，一个关于各种数据库记录的程序性视图，或者一个通往其他信息系统的网关。即使当URI映射机制与文件系统挂钩时，源服务器也可能被配置为以请求为输入执行文件，并将输出作为表示发送，而不是直接传输文件。无论如何，只有源服务器需要知道它的每个资源标识符如何对应于一个实现，以及每个实现如何管理选择并在对GET的响应中发送目标资源的当前表示。

客户可以改变GET的语义，使其成为一个 "范围请求"，通过在请求中发送一个范围首部字段，只请求传输所选表示的某些部分（[RFC 7233]）。

GET请求报文中的有效载荷没有定义语义；在GET请求中发送有效载荷体可能导致一些现有的实现拒绝该请求。

对GET请求的响应是可缓存的；除非Cache-Control首部字段另有说明，否则缓存可以使用它来满足后续的GET和HEAD请求（[RFC 7234]的第5.2节）。

### 4.3.2. HEAD

The HEAD method is identical to GET except that the server MUST NOT
send a message body in the response (i.e., the response terminates at
the end of the header section). The server SHOULD send the same
header fields in response to a HEAD request as it would have sent if
the request had been a GET, except that the payload header fields
(Section 3.3) MAY be omitted. This method can be used for obtaining
metadata about the selected representation without transferring the
representation data and is often used for testing hypertext links for
validity, accessibility, and recent modification.

A payload within a HEAD request message has no defined semantics;
sending a payload body on a HEAD request might cause some existing
implementations to reject the request.

The response to a HEAD request is cacheable; a cache MAY use it to
satisfy subsequent HEAD requests unless otherwise indicated by the
Cache-Control header field (Section 5.2 of [RFC7234]). A HEAD
response might also have an effect on previously cached responses to
GET; see Section 4.3.5 of [RFC7234].

### 4.3.3. POST

The POST method requests that the target resource process the
representation enclosed in the request according to the resource’s
own specific semantics. For example, POST is used for the following
functions (among others):

- Providing a block of data, such as the fields entered into an HTML
  form, to a data-handling process;
- Posting a message to a bulletin board, newsgroup, mailing list,
  blog, or similar group of articles;
- Creating a new resource that has yet to be identified by the
  origin server; and
- Appending data to a resource’s existing representation(s).

An origin server indicates response semantics by choosing an
appropriate status code depending on the result of processing the
POST request; almost all of the status codes defined by this
specification might be received in a response to POST (the exceptions
being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not
Satisfiable)).

If one or more resources has been created on the origin server as a
result of successfully processing a POST request, the origin server
SHOULD send a 201 (Created) response containing a Location header
field that provides an identifier for the primary resource created
(Section 7.1.2) and a representation that describes the status of the
request while referring to the new resource(s).

Responses to POST requests are only cacheable when they include
explicit freshness information (see Section 4.2.1 of [RFC7234]).
However, POST caching is not widely implemented. For cases where an
origin server wishes the client to be able to cache the result of a
POST in a way that can be reused by a later GET, the origin server
MAY send a 200 (OK) response containing the result and a
Content-Location header field that has the same value as the POST’s
effective request URI (Section 3.1.4.2).

If the result of processing a POST would be equivalent to a
representation of an existing resource, an origin server MAY redirect
the user agent to that resource by sending a 303 (See Other) response
with the existing resource’s identifier in the Location field. This
has the benefits of providing the user agent a resource identifier
and transferring the representation via a method more amenable to
shared caching, though at the cost of an extra request if the user
agent does not already have the representation cached.

### 4.3.4. PUT

The PUT method requests that the state of the target resource be
created or replaced with the state defined by the representation
enclosed in the request message payload. A successful PUT of a given
representation would suggest that a subsequent GET on that same
target resource will result in an equivalent representation being
sent in a 200 (OK) response. However, there is no guarantee that
such a state change will be observable, since the target resource
might be acted upon by other user agents in parallel, or might be
subject to dynamic processing by the origin server, before any
subsequent GET is received. A successful response only implies that
the user agent’s intent was achieved at the time of its processing by
the origin server.

If the target resource does not have a current representation and the
PUT successfully creates one, then the origin server MUST inform the
user agent by sending a 201 (Created) response. If the target
resource does have a current representation and that representation
is successfully modified in accordance with the state of the enclosed
representation, then the origin server MUST send either a 200 (OK) or
a 204 (No Content) response to indicate successful completion of the
request.

An origin server SHOULD ignore unrecognized header fields received in
a PUT request (i.e., do not save them as part of the resource state).

An origin server SHOULD verify that the PUT representation is
consistent with any constraints the server has for the target
resource that cannot or will not be changed by the PUT. This is
particularly important when the origin server uses internal
configuration information related to the URI in order to set the
values for representation metadata on GET responses. When a PUT
representation is inconsistent with the target resource, the origin
server SHOULD either make them consistent, by transforming the
representation or changing the resource configuration, or respond
with an appropriate error message containing sufficient information
to explain why the representation is unsuitable. The 409 (Conflict)
or 415 (Unsupported Media Type) status codes are suggested, with the
latter being specific to constraints on Content-Type values.

For example, if the target resource is configured to always have a
Content-Type of "text/html" and the representation being PUT has a
Content-Type of "image/jpeg", the origin server ought to do one of:

a. reconfigure the target resource to reflect the new media type;
b. transform the PUT representation to a format consistent with that
of the resource before saving it as the new resource state; or,
c. reject the request with a 415 (Unsupported Media Type) response
indicating that the target resource is limited to "text/html",
perhaps including a link to a different resource that would be a
suitable target for the new representation.

HTTP does not define exactly how a PUT method affects the state of an
origin server beyond what can be expressed by the intent of the user
agent request and the semantics of the origin server response. It
does not define what a resource might be, in any sense of that word,
beyond the interface provided via HTTP. It does not define how
resource state is "stored", nor how such storage might change as a
result of a change in resource state, nor how the origin server
translates resource state into representations. Generally speaking,
all implementation details behind the resource interface are
intentionally hidden by the server.

An origin server MUST NOT send a validator header field
(Section 7.2), such as an ETag or Last-Modified field, in a
successful response to PUT unless the request’s representation data
was saved without any transformation applied to the body (i.e., the
resource’s new representation data is identical to the representation
data received in the PUT request) and the validator field value
reflects the new representation. This requirement allows a user
agent to know when the representation body it has in memory remains
current as a result of the PUT, thus not in need of being retrieved
again from the origin server, and that the new validator(s) received
in the response can be used for future conditional requests in order
to prevent accidental overwrites (Section 5.2).

The fundamental difference between the POST and PUT methods is
highlighted by the different intent for the enclosed representation.
The target resource in a POST request is intended to handle the
enclosed representation according to the resource’s own semantics,
whereas the enclosed representation in a PUT request is defined as
replacing the state of the target resource. Hence, the intent of PUT
is idempotent and visible to intermediaries, even though the exact
effect is only known by the origin server.

Proper interpretation of a PUT request presumes that the user agent
knows which target resource is desired. A service that selects a
proper URI on behalf of the client, after receiving a state-changing
request, SHOULD be implemented using the POST method rather than PUT.
If the origin server will not make the requested PUT state change to
the target resource and instead wishes to have it applied to a
different resource, such as when the resource has been moved to a
different URI, then the origin server MUST send an appropriate 3xx
(Redirection) response; the user agent MAY then make its own decision
regarding whether or not to redirect the request.

A PUT request applied to the target resource can have side effects on
other resources. For example, an article might have a URI for
identifying "the current version" (a resource) that is separate from
the URIs identifying each particular version (different resources
that at one point shared the same state as the current version
resource). A successful PUT request on "the current version" URI
might therefore create a new version resource in addition to changing
the state of the target resource, and might also cause links to be
added between the related resources.

An origin server that allows PUT on a given target resource MUST send
a 400 (Bad Request) response to a PUT request that contains a
Content-Range header field (Section 4.2 of [RFC7233]), since the
payload is likely to be partial content that has been mistakenly PUT
as a full representation. Partial content updates are possible by
targeting a separately identified resource with state that overlaps a
portion of the larger resource, or by using a different method that
has been specifically defined for partial updates (for example, the
PATCH method defined in [RFC5789]).

Responses to the PUT method are not cacheable. If a successful PUT
request passes through a cache that has one or more stored responses
for the effective request URI, those stored responses will be
invalidated (see Section 4.4 of [RFC7234]).

### 4.3.5. DELETE

The DELETE method requests that the origin server remove the
association between the target resource and its current
functionality. In effect, this method is similar to the rm command
in UNIX: it expresses a deletion operation on the URI mapping of the
origin server rather than an expectation that the previously
associated information be deleted.

If the target resource has one or more current representations, they
might or might not be destroyed by the origin server, and the
associated storage might or might not be reclaimed, depending
entirely on the nature of the resource and its implementation by the
origin server (which are beyond the scope of this specification).
Likewise, other implementation aspects of a resource might need to be
deactivated or archived as a result of a DELETE, such as database or
gateway connections. In general, it is assumed that the origin
server will only allow DELETE on resources for which it has a
prescribed mechanism for accomplishing the deletion.

Relatively few resources allow the DELETE method -- its primary use
is for remote authoring environments, where the user has some
direction regarding its effect. For example, a resource that was
previously created using a PUT request, or identified via the
Location header field after a 201 (Created) response to a POST
request, might allow a corresponding DELETE request to undo those
actions. Similarly, custom user agent implementations that implement
an authoring function, such as revision control clients using HTTP
for remote operations, might use DELETE based on an assumption that
the server’s URI space has been crafted to correspond to a version
repository.

If a DELETE method is successfully applied, the origin server SHOULD
send a 202 (Accepted) status code if the action will likely succeed
but has not yet been enacted, a 204 (No Content) status code if the
action has been enacted and no further information is to be supplied,
or a 200 (OK) status code if the action has been enacted and the
response message includes a representation describing the status.

A payload within a DELETE request message has no defined semantics;
sending a payload body on a DELETE request might cause some existing
implementations to reject the request.

Responses to the DELETE method are not cacheable. If a DELETE
request passes through a cache that has one or more stored responses
for the effective request URI, those stored responses will be
invalidated (see Section 4.4 of [RFC7234]).

### 4.3.6. CONNETC

The CONNECT method requests that the recipient establish a tunnel to
the destination origin server identified by the request-target and,
if successful, thereafter restrict its behavior to blind forwarding
of packets, in both directions, until the tunnel is closed. Tunnels
are commonly used to create an end-to-end virtual connection, through
one or more proxies, which can then be secured using TLS (Transport
Layer Security, [RFC5246]).

CONNECT is intended only for use in requests to a proxy. An origin
server that receives a CONNECT request for itself MAY respond with a
2xx (Successful) status code to indicate that a connection is
established. However, most origin servers do not implement CONNECT.

A client sending a CONNECT request MUST send the authority form of
request-target (Section 5.3 of [RFC7230]); i.e., the request-target
consists of only the host name and port number of the tunnel
destination, separated by a colon. For example,

```http
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
```

The recipient proxy can establish a tunnel either by directly
connecting to the request-target or, if configured to use another
proxy, by forwarding the CONNECT request to the next inbound proxy.
Any 2xx (Successful) response indicates that the sender (and all
inbound proxies) will switch to tunnel mode immediately after the
blank line that concludes the successful response’s header section;
data received after that blank line is from the server identified by
the request-target. Any response other than a successful response
indicates that the tunnel has not yet been formed and that the
connection remains governed by HTTP.

A tunnel is closed when a tunnel intermediary detects that either
side has closed its connection: the intermediary MUST attempt to send
any outstanding data that came from the closed side to the other
side, close both connections, and then discard any remaining data
left undelivered.

Proxy authentication might be used to establish the authority to
create a tunnel. For example,

```http
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
Proxy-Authorization: basic aGVsbG86d29ybGQ=
```

There are significant risks in establishing a tunnel to arbitrary
servers, particularly when the destination is a well-known or
reserved TCP port that is not intended for Web traffic. For example,
a CONNECT to a request-target of "example.com:25" would suggest that
the proxy connect to the reserved port for SMTP traffic; if allowed,
that could trick the proxy into relaying spam email. Proxies that
support CONNECT SHOULD restrict its use to a limited set of known
ports or a configurable whitelist of safe request targets.

A server MUST NOT send any Transfer-Encoding or Content-Length header
fields in a 2xx (Successful) response to CONNECT. A client MUST
ignore any Content-Length or Transfer-Encoding header fields received
in a successful response to CONNECT.

A payload within a CONNECT request message has no defined semantics;
sending a payload body on a CONNECT request might cause some existing
implementations to reject the request.

Responses to the CONNECT method are not cacheable.

### 4.3.7. OPTIONS

The OPTIONS method requests information about the communication
options available for the target resource, at either the origin
server or an intervening intermediary. This method allows a client
to determine the options and/or requirements associated with a
resource, or the capabilities of a server, without implying a
resource action.

An OPTIONS request with an asterisk ("_") as the request-target
(Section 5.3 of [RFC7230]) applies to the server in general rather
than to a specific resource. Since a server’s communication options
typically depend on the resource, the "_" request is only useful as a
"ping" or "no-op" type of method; it does nothing beyond allowing the
client to test the capabilities of the server. For example, this can
be used to test a proxy for HTTP/1.1 conformance (or lack thereof).

If the request-target is not an asterisk, the OPTIONS request applies
to the options that are available when communicating with the target
resource.

A server generating a successful response to OPTIONS SHOULD send any
header fields that might indicate optional features implemented by
the server and applicable to the target resource (e.g., Allow),
including potential extensions not defined by this specification.
The response payload, if any, might also describe the communication
options in a machine or human-readable representation. A standard
format for such a representation is not defined by this
specification, but might be defined by future extensions to HTTP. A
server MUST generate a Content-Length field with a value of "0" if no
payload body is to be sent in the response.

A client MAY send a Max-Forwards header field in an OPTIONS request
to target a specific recipient in the request chain (see
Section 5.1.2). A proxy MUST NOT generate a Max-Forwards header
field while forwarding a request unless that request was received
with a Max-Forwards field.

A client that generates an OPTIONS request containing a payload body
MUST send a valid Content-Type header field describing the
representation media type. Although this specification does not
define any use for such a payload, future extensions to HTTP might
use the OPTIONS body to make more detailed queries about the target
resource.

Responses to the OPTIONS method are not cacheable.

### 4.3.8. TRACE

The TRACE method requests a remote, application-level loop-back of
the request message. The final recipient of the request SHOULD
reflect the message received, excluding some fields described below,
back to the client as the message body of a 200 (OK) response with a
Content-Type of "message/http" (Section 8.3.1 of [RFC7230]). The
final recipient is either the origin server or the first server to
receive a Max-Forwards value of zero (0) in the request
(Section 5.1.2).

A client MUST NOT generate header fields in a TRACE request
containing sensitive data that might be disclosed by the response.
For example, it would be foolish for a user agent to send stored user
credentials [RFC7235] or cookies [RFC6265] in a TRACE request. The
final recipient of the request SHOULD exclude any request header
fields that are likely to contain sensitive data when that recipient
generates the response body.

TRACE allows the client to see what is being received at the other
end of the request chain and use that data for testing or diagnostic
information. The value of the Via header field (Section 5.7.1 of
[RFC7230]) is of particular interest, since it acts as a trace of the
request chain. Use of the Max-Forwards header field allows the
client to limit the length of the request chain, which is useful for
testing a chain of proxies forwarding messages in an infinite loop.

A client MUST NOT send a message body in a TRACE request.

Responses to the TRACE method are not cacheable.

# 5. 请求首部字段
