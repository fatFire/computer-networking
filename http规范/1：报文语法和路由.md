- [1. 介绍](#1-介绍)
  - [1.1. 要求记号](#11-要求记号)
  - [1.2. 语法记号](#12-语法记号)
- [2. 架构](#2-架构)
  - [2.1. 客户/服务器交换报文](#21-客户服务器交换报文)
  - [2.2. 实现多样性](#22-实现多样性)
  - [2.3. 中介](#23-中介)
  - [2.4. 缓存](#24-缓存)
  - [2.5. 符合性和错误处理](#25-符合性和错误处理)
  - [2.6. 协议版本](#26-协议版本)
  - [2.7. 统一资源标识符(URI)](#27-统一资源标识符uri)
    - [2.7.1. http URI 方案](#271-http-uri-方案)
    - [2.7.2. https URI 方案](#272-https-uri-方案)
    - [2.7.3. http 和 https URI 的标准化和比较](#273-http-和-https-uri-的标准化和比较)
- [3. 报文格式](#3-报文格式)
  - [3.1. 起始行](#31-起始行)
    - [3.1.1. 请求行](#311-请求行)
    - [3.1.2. 状态行](#312-状态行)
  - [3.2. 首部字段](#32-首部字段)
    - [3.2.1. 字段扩展性](#321-字段扩展性)
    - [3.2.2. 字段顺序](#322-字段顺序)
    - [3.2.3. 空白](#323-空白)
    - [3.2.4. 字段解析](#324-字段解析)
    - [3.2.5. 字段限制](#325-字段限制)
    - [3.2.6. 字段值部分](#326-字段值部分)
  - [3.3. 报文体](#33-报文体)
    - [3.3.1. Transfer-Encoding](#331-transfer-encoding)
    - [3.3.2. Content-Length](#332-content-length)
    - [3.3.3. 报文体长度](#333-报文体长度)
  - [3.4. 处理不完整的报文](#34-处理不完整的报文)
  - [3.5. 报文解析健壮性](#35-报文解析健壮性)
- [4. 传输编码](#4-传输编码)
  - [4.1. 分块传输编码](#41-分块传输编码)
    - [4.1.1. 块扩展](#411-块扩展)
    - [4.1.2. 分块 Trailer-Part](#412-分块-trailer-part)
    - [4.1.3. 解码分块](#413-解码分块)
    - [4.1.4. 压缩编码](#414-压缩编码)
    - [4.1.5. 压缩地编码](#415-压缩地编码)
    - [4.1.6. 释义编码](#416-释义编码)
    - [4.1.7. Gzip 编码](#417-gzip-编码)
  - [4.2. TE](#42-te)
  - [4.3. Trailer](#43-trailer)
- [5. 报文路由](#5-报文路由)
  - [5.1. 识别目标资源](#51-识别目标资源)
  - [5.2. 连接入站](#52-连接入站)
  - [5.3. 请求目标](#53-请求目标)
    - [5.3.1. 原始形式](#531-原始形式)
    - [5.3.2. 绝对形式](#532-绝对形式)
    - [5.3.3. 权威形式](#533-权威形式)
    - [5.3.4. 星号形式](#534-星号形式)
  - [5.4. Host](#54-host)
  - [5.5. 有效请求URI](#55-有效请求uri)
  - [5.6. 将响应与请求相关联](#56-将响应与请求相关联)
  - [5.7. 报文转发](#57-报文转发)
    - [5.7.1. Via](#571-via)
    - [5.7.2. 转译](#572-转译)
- [6. 连接管理](#6-连接管理)
  - [6.1. 连接](#61-连接)
  - [6.2. 建立](#62-建立)
  - [6.3. 持久](#63-持久)
    - [6.3.1. 重试请求](#631-重试请求)
    - [流水线](#流水线)
  - [并发](#并发)
  - [失败和超时](#失败和超时)
  - [拆除](#拆除)
  - [升级](#升级)

# 1. 介绍

**超文本传输协议(Hypertext Transfer Protocol, HTTP)** 是一个无状态的应用级请求/响应协议，它使用可扩展的语义和自我描述的报文有效载荷，与基于网络的超文本报文系统进行灵活的交互。本文件是一系列文件中的第一个，这些文件共同构成了 HTTP/1.1 规范：

1. “报文语法和路由”（本文件）
2. “语义和内容” [RFC 7231]
3. “条件请求” [RFC 7232]
4. “范围请求” [RFC 7233]
5. “缓存” [RFC 7234]
6. “认证” [RFC 7235]

这个 HTTP/1.1 规范废除了 RFC 2616 和 RFC 2145（关于 HTTP 版本）。该规范还更新了以前在 RFC 2817 中定义的使用 CONNECT 建立隧道的方法，并定义了在 RFC 2818 中非正式描述的 “https” URI 方案。

HTTP 是一个报文系统的通用接口协议。它旨在通过向客户提供一个独立于所提供的资源类型的统一接口，来隐藏服务实现的细节。同样，服务器也不需要知道每个客户的目的：一个 HTTP 请求可以被独立地考虑，而不是与特定类型的客户或预先确定的应用步骤序列相关联。其结果是一个可以在许多不同的环境中有效使用的协议，其实现可以随着时间的推移独立发展。

HTTP 也被设计为一种中介协议，用于转译与非 HTTP 报文系统的通信。HTTP 代理和网关可以提供对其他报文服务的访问，将其不同的协议转译成超文本格式，可以被客户以与 HTTP 服务相同的方式查看和操作。

这种灵活性的一个后果是，不能用接口后面发生的事情来定义协议。相反，我们只限于定义通信的语法、接收通信的意图以及接收方的预期行为。如果通信被孤立地考虑，那么成功的行动应该反映在对服务器提供的可观察界面的相应改变中。然而，由于多个客户可能平行行动，而且可能是交叉行动，我们不能要求这种变化在单个响应的范围之外可以观察到。

本文件描述了在 HTTP 中使用或提及的架构的基本组成，定义了 “http” 和 “https” URI 方案，描述了整体网络运作和连接管理，并定义了 HTTP 报文架构和转发要求。我们的目标是定义所有独立于报文语义的 HTTP 报文处理所需的机制，从而为报文解析器和报文转发中介机构定义一套完整的要求。

## 1.1. 要求记号

本文档中的关键词 "必须"、"不得"、"需要"、"Shall"、"SHALL NOT"、"应该"、"推荐"、可以" 和 "可选" 应按照[RFC 2119]中的描述进行解释。

有关错误处理的符合性标准和注意事项在第 2.5 节中定义。

## 1.2. 语法记号

本规范使用 [RFC 5234] 的 Augmented Backus-Naur Form (ABNF) 计法，并在第 7 节中定义了一个列表扩展，允许使用'#'运算符（类似于'\*'运算符表示重复的方式）紧凑地定义逗号分隔的列表。附录 B 显示了收集的语法，其中所有的列表操作符都扩展为标准的 ABNF 符号。

以下核心规则通过参考包括在 [RFC 5234] 附录 B.1 中的定义。ALPHA（字母）、CR（回车）、CRLF（CR LF）、CTL（控制）、DIGIT（十进制 0-9）、DQUOTE（双引号）、HEXDIG（十六进制 0-9/A-F/a-f）、HTAB（水平制表符）、LF（换行）、OCTET（任何 8 位数据序列）、SP（空格）和 VCHAR（任何可见[USASCII]字符）。

按照惯例，ABNF 规则名称前缀为 "obs-"，表示由于历史原因出现的 "过时 "语法规则。

# 2. 架构

HTTP 是为万维网(WWW)架构而创建的，并随着时间的推移不断发展，以支持全球超文本系统的可扩展性需求。该架构的大部分内容反映在用于定义 HTTP 的术语和语法产生式上。

## 2.1. 客户/服务器交换报文

HTTP 是一个无状态的请求/响应协议，通过可靠的传输层或会话层的 “连接”（第 6 节）交换报文（第 3 节）。一个 HTTP “**客户(client)**” 是一个程序，它建立了一个与服务器的连接，目的是发送一个或多个 HTTP 请求。HTTP “**服务器(server)**” 是一个接受连接的程序，以便通过发送 HTTP 响应来服务 HTTP 请求。

术语 "客户"和 "服务器" 仅指这些程序在特定连接中所扮演的角色。同一个程序可能在某些连接上充当客户，而在其他连接上充当服务器。术语 "**用户代理(user agent)**" 是指发起请求的各种客户程序，包括（但不限于）浏览器、爬虫（基于网络的机器人）、命令行工具、定制化应用程序和移动应用程序。术语 "**源服务器(origin server)**" 指的是能够为特定目标资源发起权威响应的程序。术语 "**发送方(sender)**"和 "**接收方(recipent)**"分别指发送或接收特定报文的任何实现。

HTTP 依靠 **统一资源标识符(Uniform Resource Identifier, URI)** 标准[RFC 3986]来表示目标资源（第 5.1 节）和资源之间的关系。报文的传递格式类似于互联网邮件[RFC 5322]和多用途互联网邮件扩展（MIME）[RFC 2045]所使用的格式（关于 HTTP 和 MIME 报文的区别，请参见[RFC 7231]的附录 A）。

大多数 HTTP 通信包括对由 URI 识别的某些资源的表示的检索请求（GET）。在最简单的情况下，这可能是通过用户代理（UA）和源服务器（O）之间的单一双向连接（==）完成的。

```
        请求 >>>
UA ======================================= O
                                <<< 响应
```

客户以请求报文的形式向服务器发送一个 HTTP 请求，以包括方法、URI 和协议版本的请求行开始（第 3.1.1 节），然后是包含请求修饰词、客户报文和表示元数据的首部字段（第 3.2 节），一个空行表示首部的结束，最后是包含有效载荷的报文体（如果有的话，第 3.3 节）。

服务器通过发送一个或多个 HTTP 响应报文来响应客户的请求，每个响应报文以一个状态行开始，其中包括协议版本、成功或错误代码以及文本原因短语（第 3.1.2 节），后面可能是包含服务器报文、资源元数据和表示元数据的首部字段（第 3.2 节），一个空行表示首部的结束，最后是包含有效载荷的报文体（如果有的话，第 3.3 节）。

一个连接可能用于多个请求/响应交互，如第 6.3 节所定义。

下面的例子说明了 URI "http://www.example.com/hello.txt"的GET请求（[RFC 7231]第 4.3.1 节）的典型报文交互。

客户请求：

```http
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi
```

服务器响应：

```http
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain

Hello World! My payload includes a trailing CRLF.
```

## 2.2. 实现多样性

在考虑 HTTP 的设计时，很容易落入一个陷阱，认为所有的用户代理都是通用的浏览器，所有的源服务器都是大型的公共网站。实际情况并非如此。常见的 HTTP 用户代理包括家用电器、音响、天平、固件更新脚本、命令行程序、移动应用程序以及各种形状和大小的通信设备。同样，常见的 HTTP 源服务器包括家庭自动化装置、可配置的网络部分、办公机器、自动机器人、新闻源、交通摄像首部、广告选择器和视频交付平台。

术语 "用户代理" 并不意味着在请求时有一个人类用户直接与软件代理进行互动。在许多情况下，用户代理被安装或配置为在后台运行，并保存其结果供以后检查（或只保存那些可能有趣或错误的结果的子集）。例如，爬虫通常被赋予一个起始 URI，并被配置为在作为超文本图抓取网络时遵循某些行为。

HTTP 的实现多样性意味着并非所有的用户代理都能向他们的用户提出交互式建议，或为安全或隐私问题提供足够的警告。在本规范要求向用户报告错误的少数情况下，这种报告只在错误控制台或日志文件中可以观察到是可以接受的。同样地，要求自动操作在进行之前由用户确认的要求可以通过预先的配置选择、运行时选项或简单地避免不安全的动作；如果用户已经做出了选择，确认并不意味着任何特定的用户界面或中断正常处理。

## 2.3. 中介

HTTP 允许使用中介，通过一连串的连接来满足请求。有三种常见的 HTTP 中介形式：代理、网关和隧道。在某些情况下，一个中介可能充当源服务器、代理、网关或隧道，根据每个请求的性质切换行为。

```
    >>>         >>>         >>>         >>>
UA =========== A =========== B =========== C =========== O
            <<<             <<<           <<<        <<<
```

上图显示了用户代理和源服务器之间的三个中介（A、B 和 C）。一个穿越整个链条的请求或响应报文将通过四个独立的连接。一些 HTTP 通信选项可能只适用于与最近的、非隧道邻接节点的连接，只适用于链的端点，或适用于沿链的所有连接。尽管图表是线性的，但每个参与者都可能参与多个同时进行的通信。例如，B 在处理 A 的请求的同时，可能正在接收来自 A 以外的许多客户的请求，和/或将请求转发给 C 以外的服务器。同样，后来的请求可能会通过不同的连接路径发送，通常是基于负载平衡的动态配置。

术语 "**上游(upstream)**" 和 "**下游(downstream)**" 用于描述与报文流有关的方向性要求：所有报文都从上游流向下游。术语 "**(inbound)**" 和 "**出站(outbound)**" 用于描述与请求路线有关的方向性要求。"入站" 是指朝向源服务器，"出站" 是指朝向用户代理。

**代理(proxy)**"是一个报文转发代理，由客户选择，通常通过本地配置规则，接收对某些类型的绝对 URI 的请求，并试图通过 HTTP 接口的转译来满足这些请求。一些转译是最小的，例如对 “http” URI 的代理请求，而其他请求可能需要转译成完全不同的应用级协议。为了安全、注释服务或共享缓存，代理通常被用来通过一个共同的中介来组合一个组织的 HTTP 请求。一些代理被设计成在转发时对选定的报文或有效载荷进行转换，如 5.7.2 节所述。

**网关(gateway)** "（又称 "反向代理"）是一个中介，它作为出站连接的源服务器，它转译收到的请求并将其转发到另一个或多个服务器。网关经常被用来封装传统的或不被信任的报文服务，通过 "加速器" 缓存来提高服务器的性能，并实现 HTTP 服务在多台机器上的分区或负载平衡。

所有适用于源服务器的 HTTP 要求也适用于网关的出站通信。网关使用它所希望的任何协议与入站服务器进行通信，包括本规范范围之外的 HTTP 的私有扩展。然而，一个希望与第三方 HTTP 服务器互通的 HTTP-to-HTTP 网关应该符合网关入站连接的用户代理要求。

**隧道(tunnel)** "作为两个连接之间的无目的中继，不改变报文。一旦激活，隧道不被认为是 HTTP 通信的一方，尽管隧道可能是由一个 HTTP 请求发起的。当中继连接的两端都关闭时，隧道就不存在了。隧道被用来通过一个中介扩展一个虚拟连接，例如，当传输层安全（TLS，[RFC 5246]）被用来通过一个共享的防火墙代理建立保密通信。

上述中介的类别只考虑那些作为 HTTP 通信的参与者。也有一些中介可以在网络协议栈的较低层发挥作用，在报文发送方不知情或没有许可的情况下过滤或重定向 HTTP 流量。网络中介（在协议层面）与中间人攻击没有区别，往往由于错误地违反了 HTTP 语义而引入安全缺陷或互操作性问题。

例如，"拦截代理"[RFC 3040]（通常也被称为 "透明代理"[RFC 1919]或 "圈养门户"）与 HTTP 代理不同，因为它不是由客户选择的。相反，拦截代理过滤或重定向传出的 TCP 80 端口数据包（偶尔也有其他普通端口流量）。拦截代理通常出现在公共网络接入点上，作为在允许使用非本地互联网服务之前执行账户订阅的一种手段，以及在企业防火墙内执行网络使用政策。

HTTP 被定义为一个无状态协议，这意味着每个请求报文都可以被独立地理解。许多实现都依赖于 HTTP 的无状态设计，以便重复使用代理连接或在多个服务器上动态地平衡请求。因此，服务器不能假定同一连接上的两个请求是来自同一个用户代理，除非该连接是安全的，并且是特定于该代理的。一些非标准的 HTTP 扩展（例如，[RFC 4559]）已经被认为违反了这一要求，导致了安全和互操作性问题。

## 2.4. 缓存

**缓存(cache)** "是过去响应报文的本地存储，是控制其报文存储、检索和删除的子系统。缓存存储可缓存响应，以减少未来同等请求的响应时间和网络带宽消耗。任何客户或服务器都可以使用缓存，尽管服务器在作为隧道时不能使用缓存。

缓存的作用是，如果链上的一个参与者有一个适用于该请求的缓存响应，那么请求/响应链就会缩短。下面说明了如果 B 拥有 O（通过 C）对一个没有被 UA 或 A 缓存的请求的早期响应的缓存副本，那么产生的链。

```
    >>>         >>>         >>>         >>>
UA =========== A =========== B - - - - - - C - - - - - - O
            <<<             <<<           <<<        <<<
```

如果允许缓存存储响应报文的副本以用于回答后续请求，那么响应就是 "可缓存的"。即使一个响应是可缓冲的，也可能有客户或原服务器对该缓冲响应何时可用于特定请求的额外限制。HTTP 对缓冲行为和可缓冲响应的要求在[RFC 7234]的第 2 节中定义。

在万维网和大型组织内部部署了各种各样的架构和缓存配置。这些包括国家层次的代理缓存以节省跨洋带宽，广播或多播缓存条目的协作系统，用于离线或高延迟环境的预取缓存条目的档案，等等。

## 2.5. 符合性和错误处理

本规范根据 HTTP 通信中的参与者的角色来确定符合性标准。因此，HTTP 要求被置于发送方、接收方、客户、服务器、用户代理、中介、源服务器、代理、网关或缓存上，这取决于什么行为被要求所限制。额外的（社会）要求被放在实现、资源所有者和协议元素注册上，当它们适用于单个通信的范围之外。

动词 "生成" 被用来代替 "发送"，当需求区分了创建协议元素和仅仅将收到的元素转发给下游时。

如果一个实现符合与它在 HTTP 中的角色相关的所有要求，那么它就被认为是符合的。

符合性包括协议元素的语法和语义。发送方 **不得** 生成传达错误含义的协议元素，而该发送方知道这一点。发送方 **不得** 产生不符合相应 ABNF 规则所定义的语法的协议元素。在一个给定的报文中，发送方 **不得** 生成只允许由其他角色的参与者（即发送方对该报文不具有的角色）生成的协议元素或语法替代。

当收到的协议元素被解析时，接收方 **必须** 能够解析适用于接收方角色的任何合理长度的值，并且与相应的 ABNF 规则所定义的语法相匹配。然而，请注意，一些收到的协议元素可能不会被解析。例如，转发报文的中间人可能会将首部字段解析为通用的字段名和字段值成分，但随后转发首部字段，而不进一步解析字段值内部。

HTTP 对它的许多协议元素没有具体的长度限制，因为可能适合的长度会有很大的不同，取决于部署环境和实现的目的。因此，发送方和接收方之间的互操作性取决于对每个协议元素的合理长度的共同期望。此外，在过去 20 年的 HTTP 使用过程中，人们普遍认为某些协议元素的合理长度已经发生了变化，预计未来还会继续变化。

至少，接收方 **必须** 能够解析和处理协议元素的长度，至少与它在其他报文中为这些相同的协议元素产生的值一样长。例如，一个发布非常长的 URI 引用到它自己的资源的初始服务器需要能够在收到请求目标时解析和处理这些相同的引用。

接收方 **必须** 根据本规范为其定义的语义（包括本规范的扩展）来解释收到的协议元素，除非接收方（通过经验或配置）确定发送方不正确地实现这些语义所暗示的内容。例如，如果对 User-Agent 首部字段的检查表明一个特定的实现版本在收到某些内容编码时是失败的，那么一个原点服务器可能会忽略收到的 Accept-Encoding 首部字段的内容。

除非另有说明，接收方 **可以** 尝试从一个无效的结构中恢复一个可用的协议元素。HTTP 没有定义具体的错误处理机制，除非它们对安全有直接影响，因为协议的不同应用需要不同的错误处理策略。例如，网络浏览器可能希望透明地从位置首部字段没有按照 ABNF 解析的响应中恢复，而系统控制客户可能认为任何形式的错误恢复都是危险的。

## 2.6. 协议版本

HTTP 使用"<主要版本号>.<次要版本号>"的编号方案来表示协议的版本。本规范定义了 "1.1" 版本。协议版本作为一个整体表明发送方符合该版本对应的 HTTP 规范中规定的一系列要求。

HTTP 报文的版本由报文第一行的 HTTP-version 字段表示。HTTP-version 是区分大小写的。

```
HTTP-version = HTTP-name "/" DIGIT "." DIGIT
HTTP-name = %x48.54.54.50 ; "HTTP", case-sensitive
```

HTTP 版本号由两位小数组成，以"."（句号或小数点）分开。第一个数字（"主要版本号"）表示 HTTP 报文传输语法，而第二个数字（"次要版本号"）表示该主要版本中最高的次要版本，发送方符合并能够理解该版本，以便将来进行通信。次要版本通告发送方的通信能力，即使发送方只使用协议的向后兼容的子集，从而让接收方知道，更高级的功能可以在响应（由服务器）或未来的请求（由客户）中使用。

当 HTTP/1.1 报文被发送到 HTTP/1.0 接收方[RFC 1945]或版本未知的接收方时，HTTP/1.1 报文的构造是，如果所有较新的功能被忽略，它可以被解释为一个有效的 HTTP/1.0 报文。本规范对一些新特性提出了接收方版本的要求，这样符合要求的发送方将只使用兼容的特性，直到它通过配置或收到的报文确定接收方支持 HTTP/1.1。

一个首部字段的解释在同一主要 HTTP 版本的不同次要版本之间不会改变，尽管接收方在没有这样一个字段时的默认行为可能会改变。除非另有规定，在 HTTP/1.1 中定义的首部字段是为 HTTP/1.x 的所有版本定义的。特别是，所有 HTTP/1.x 的实现都应该实现 Host 和 Connection 首部字段，不管它们是否通告与 HTTP/1.1 一致。

如果新的首部字段定义的语义允许它们被不认识它们的接收方安全地忽略，那么可以在不改变协议版本的情况下引入这些字段。3.2.1 节中讨论了首部字段的可扩展性。

处理 HTTP 报文的中介（即除了作为隧道的中介以外的所有中介）必须在转发的报文中发送自己的 HTTP 版本。换句话说，他们不允许无目的地转发 HTTP 报文的第一行，而不确保该报文中的协议版本与该中介在接收和发送报文时符合的版本一致。在没有重写 HTTP-版本的情况下转发 HTTP 报文，当下游接收方使用报文发送方的版本来确定以后与该发送方的通信可以安全使用哪些功能时，可能会导致通信错误。

客户应该发送一个与客户符合的最高版本相等的请求版本，并且其主要版本不高于服务器所支持的最高版本，如果这是已知的。客户决不能发送它不符合的版本。

如果知道服务器不正确地实现了 HTTP 规范，客户可能会发送一个较低的请求版本，但只有在客户尝试了至少一个正常的请求并从响应状态代码或标题字段（例如，服务器）确定服务器不正确地处理较高的请求版本之后。

服务器应该发送一个等于服务器符合的最高版本的响应版本，该版本的主要版本小于或等于请求中收到的版本。服务器不应该发送它不符合的版本。如果服务器出于任何原因希望拒绝为客户的主要协议版本提供服务，它可以发送一个 505（HTTP Version Not Supported）响应。

如果已知或怀疑客户不正确地实现了 HTTP 规范，并且没有能力正确地处理后来的版本响应，例如，当客户未能正确地解析版本号时，或者当已知中介机构盲目地转发 HTTP-版本时，即使它不符合给定的协议的次要版本，服务器可能会对请求发送 HTTP/1.0 响应。这种协议降级不应该被执行，除非由特定的客户属性触发，例如当一个或多个请求首部字段（如 User-Agent）与已知有错误的客户发送的值唯一匹配时。

HTTP 版本设计的意图是，只有在引入不兼容的报文语法时，才会增加主版本号，而只有在对协议的修改具有增加报文语义或暗示发送方的额外能力的效果时，才会增加次版本号。然而，在[RFC 2068]和[RFC 2616]之间引入的变化中，次要版本没有被递增，这次修订特别避免了对协议的任何此类变化。

当收到一个 HTTP 报文，其主要版本号是接收方实现的，但其次要版本号比接收方实现的要高，接收方应将该报文作为接收方符合的该主要版本中的最高次要版本来处理。接收方可以认为，当发送至尚未表示支持更高版本的接收方时，具有更高次要版本的报文是充分向后兼容的，可以被同一主要版本的任何实现安全地处理。

## 2.7. 统一资源标识符(URI)

统一资源标识符（URI）[RFC 3986]在整个 HTTP 中被用作识别资源的方法（[RFC 7231]第 2 节）。URI 引用被用来定位请求，指示重定向，并定义关系。

URI-reference"、"absolute-URI"、"relative-part"、"scheme"、"authority"、"port"、"host"、"path-abempty"、"segment"、"query "和 "fragment "的定义来自 URI 通用语法。一个 "绝对路径 "规则被定义为可以包含一个非空的路径部分的协议元素。(这个规则与 RFC 3986 的 path-abempty 规则略有不同，后者允许在引用中使用空路径，而 path-absolute 规则则不允许以"//"开首部的路径）。) "部分 URI "规则是为可以包含相对 URI 但不包含片段成分的协议元素而定义的。

```
URI-reference = <URI-reference, see [RFC3986], Section 4.1>
absolute-URI = <absolute-URI, see [RFC3986], Section 4.3>
relative-part = <relative-part, see [RFC3986], Section 4.2>
scheme = <scheme, see [RFC3986], Section 3.1>
authority = <authority, see [RFC3986], Section 3.2>
uri-host = <host, see [RFC3986], Section 3.2.2>
port = <port, see [RFC3986], Section 3.2.3>
path-abempty = <path-abempty, see [RFC3986], Section 3.3>
segment = <segment, see [RFC3986], Section 3.3>
query = <query, see [RFC3986], Section 3.4>
fragment = <fragment, see [RFC3986], Section 3.5>

absolute-path = 1*( "/" segment )
partial-URI = relative-part [ "?" query ]
```

HTTP 中每个允许 URI 引用的协议元素将在其 ABNF 生产中指出该元素是否允许任何形式的引用（URI-reference），只允许绝对形式的 URI（absolute-URI），只允许路径和可选查询部分，或上述的一些组合。除非另有说明，URI 引用是相对于有效请求 URI 解析的（第 5.5 节）。

### 2.7.1. http URI 方案

在此定义 “http” URI 方案，目的是根据其与潜在的 HTTP 源服务器在特定端口上监听 TCP（[RFC 0793]）连接所管理的层次化命名空间的关联来生成标识符。

```
http-URI = "http:" "//" authority path-abempty [ "?" query ] [ "#" fragment ]
```

http "URI 的源服务器是由权威确定的，其中包括一个主机标识和可选的 TCP 端口（[RFC 3986]，第 3.2.2 节）。分层路径部分和可选的查询部分作为该源服务器命名空间中潜在目标资源的标识符。如[RFC 3986]第 3.5 节所定义，可选片段部分允许间接识别二级资源，与 URI 方案无关。

发送方 **不得** 生成带有空主机标识符的 “http” URI。处理这种 URI 引用的接收方必须拒绝它，因为它是无效的。

如果主机标识符被提供为一个 IP 地址，那么源服务器就是该 IP 地址上指定的 TCP 端口的监听器（如果有的话）。如果主机是一个注册的域名，注册的域名是一个间接的标识符，用于域名解析服务，如 DNS，为该源服务器找到一个地址。如果端口子部分是空的或没有给出，TCP 端口默认为 80（为 WWW 服务保留的端口）。

请注意，一个具有特定权限部分的 URI 的存在并不意味着总是有一个 HTTP 服务器在监听该主机和端口的连接。任何人都可以铸造一个 URI。权威部分所决定的是谁有权对针对所识别资源的请求作出权威性的回应。注册名称和 IP 地址的授权性质创建了一个联合名称空间，基于对指定主机和端口的控制，无论是否有 HTTP 服务器存在。与建立授权有关的安全考虑见第 9.1 节。

当 “http” URI 被用于要求访问指定资源的上下文中时，客户可以通过将主机解析为一个 IP 地址，在指定的端口上与该地址建立一个 TCP 连接，并向服务器发送一个包含 URI 识别数据（第 5 节）的 HTTP 请求报文（第 3 节）来尝试访问。如果服务器用非间断的 HTTP 响应报文回应该请求，如[RFC 7231]第 6 节所述，那么该响应被认为是对客户请求的权威性回答。

尽管 HTTP 独立于传输协议，但 “http” 方案是基于 TCP 的服务所特有的，因为名称委托过程依赖于 TCP 来建立权威。基于其他底层连接协议的 HTTP 服务大概会使用不同的 URI 方案来识别，就像 "https" 方案（下文）用于需要端到端安全连接的资源。其他协议也可能被用来提供对 “http” 标识的资源的访问--只有权威接口是特定于 TCP 的。

权威的 URI 通用语法还包括一个废弃的 userinfo 子部分（[RFC 3986]，第 3.2.1 节），用于在 URI 中包括用户认证报文。一些实现将 userinfo 部分用于认证报文的内部配置，例如在命令调用选项、配置文件或书签列表中，尽管这种用法可能会暴露用户标识符或密码。当 “http” URI 引用作为请求目标或首部字段值在报文中生成时，发送方不得生成 userinfo 子部分（及其"@"分隔符）。在使用从不可信任的来源收到的 “http” URI 引用之前，接收方应该解析用户报文，并将其存在视为一个错误；它很可能被用来掩盖权限，以进行网络钓鱼攻击。

### 2.7.2. https URI 方案

在此定义 "https" URI 方案，目的是根据标识符与潜在的 HTTP 起源服务器为 TLS 安全连接监听给定的 TCP 端口所管辖的分层命名空间的关联来铸造标识符（[RFC 5246]）。

上面列出的对 "http" 方案的所有要求也是对 "https" 方案的要求，但如果端口子组件为空或未给出，则 TCP 端口 443 是默认的，而且用户代理必须确保在发送第一个 HTTP 请求之前，通过使用强大的加密技术，端到端确保其与源服务器的连接是安全的。

```
https-URI = "https:" "//" authority path-abempty [ "?" query ] [ "#" fragment ]
```

请注意，"https "URI 方案依赖于 TLS 和 TCP 来建立权威。通过 "https" 方案提供的资源与 "http" 方案没有共同的身份，即使它们的资源标识符显示相同的授权（同一主机监听同一 TCP 端口）。它们是不同的命名空间，被认为是不同的起源服务器。然而，被定义为适用于整个主机域的 HTTP 的扩展，如 Cookie 协议[RFC 6265]，可以允许一个服务设置的报文影响与匹配的主机域组中的其他服务的通信。

[RFC 2818]中定义了对 "https" 标识资源的权威性访问过程。

### 2.7.3. http 和 https URI 的标准化和比较

由于 "http" 和 "https" 方案符合 URI 的通用语法，这种 URI 被标准化，并根据[RFC 3986]第 6 节中定义的算法进行比较，使用上述每种方案的默认值。

如果端口等于某个方案的默认端口，正常形式是省略端口子部分。当不是以绝对形式作为 OPTIONS 请求的请求目标时，空的路径组件等同于"/"的绝对路径，所以正常的形式是提供"/"的路径来代替。方案和主机是不区分大小写的，通常以小写提供；所有其他组件以区分大小写的方式进行比较。除 "保留" 集的字符外，其他字符相当于其百分比编码的八位数：正常形式是不对其进行编码（见[RFC 3986]第 2.1 和 2.2 节）。

例如，以下的 3 个 URI 是相等的：

```
http://example.com:80/˜smith/home.html
http://EXAMPLE.com/%7Esmith/home.html
http://EXAMPLE.com:/%7esmith/home.html
```

# 3. 报文格式

所有的 HTTP/1.1 报文都由一个起始行组成，后面是一串格式类似于互联网报文格式[RFC 5322]的八位数：零个或多个首部字段（统称为 "首部"或 "首部区域"），一个表示首部区域结束的空行，以及一个可选的报文体。

```
HTTP-message = start-line
               *( header-field CRLF )
               CRLF
               [ message-body ]
```

解析 HTTP 报文的正常程序是将起始行读入一个结构，按字段名将每个首部字段读入一个哈希表，直到空行为止，然后使用解析后的数据来确定是否期望有一个报文体。如果显示有报文体，那么它将作为一个流被读取，直到读取到与报文体长度相等的八位数或连接被关闭。

接收方 **必须** 将 HTTP 报文解析为一个八位数的序列，其编码是 US-ASCII[USASCII]的超集。将 HTTP 报文解析为 Unicode 字符流，而不考虑具体的编码。由于字符串处理库处理包含八位数 LF(%x0A)的无效多字节字符序列的方式不同，因此会产生安全漏洞。基于字符串的解析器只能在协议元素从报文中提取后安全地使用，例如在报文解析划定各个字段后，在首部字段-值中使用。

一个 HTTP 报文可以被解析为一个流，用于增量处理或转发到下游。然而，接收方不能依赖部分报文的递增交付，因为有些实现会为了网络效率、安全检查或有效载荷的转换而缓冲或延迟报文的转发。

发送方 **不得** 在起始行和第一个首部字段之间发送空白。接收方如果收到在起始行和第一个首部字段之间的空白，必须拒绝该报文为无效，或者在不进一步处理的情况下消耗每一个以空白为前导的行（即，忽略整个行，以及任何以空白为前导的后续行，直到收到一个正确形成的首部字段或首部区域被终止）。

在请求中出现这样的空白可能是试图欺骗服务器忽略该字段或将其后面的行作为一个新的请求来处理，如果请求链中的其他实现对同一报文有不同的解释，这两种情况都可能导致安全漏洞。同样，在响应中出现这样的空白可能会被一些客户忽略或导致其他客户停止解析。

## 3.1. 起始行

一条 HTTP 报文可以是客户到服务器的请求，也可以是服务器到客户的响应。从语法上讲，这两种类型的报文只在起始行上有区别，起始行可以是 **请求行**（用于请求），也可以是 **状态行**（用于响应），以及确定报文体长度的算法（第 3.3 节）。

在理论上，客户可以接收请求，服务器可以接收响应，通过不同的起始行格式来区分它们，但是，在实践中，服务器被实现为只期望一个请求（响应被解释为一个未知或无效的请求方法），而客户被实现为只期望一个响应。

```
start-line = request-line / status-line
```

### 3.1.1. 请求行

一个请求行以一个方法标记开始，然后是一个空格（SP），请求目标，另一个空格（SP），协议版本，最后以 CRLF 结束。

```
request-line = method SP request-target SP HTTP-version CRLF
```

方法标记表示要对目标资源执行的请求方法。请求方法是区分大小写的。

```
method = token
```

本规范所定义的请求方法可以在[RFC 7231]的第 4 节中找到，同时还有关于 HTTP 方法注册的报文和定义新方法的注意事项。

**请求目标(request-target)** 标识了应用该请求的目标资源，如第 5.3 节所定义。

接收方通常通过分割空白处来解析请求行的组成部分（见第 3.5 节），因为三个组成部分中不允许有空白。不幸的是，一些用户代理未能正确编码或排除超文本引用中的空白，导致这些不允许的字符被发送到请求目标中。

无效请求行的接收方应该以 400(Bad Request)错误或 301(Moved Permanently)重定向来回应，并对请求目标进行正确编码。接收方不应该试图自动更正，然后在没有重定向的情况下处理请求，因为无效的请求行可能是故意制作的，以绕过请求链上的安全过滤器。

如第 2.5 节所述，HTTP 没有对请求行的长度进行预定义的限制。一个服务器如果收到一个比它所实现的任何方法都长的方法，应该用 501(Not Implemented)状态代码来响应。如果服务器收到的请求目标长于它希望解析的任何 URI，则必须以 414(URI Too Long)状态代码进行响应（参见第 6.5.12 节[RFC 7231]）。

在实践中会发现对请求行长度的各种特别限制。建议所有 HTTP 发送方和接收方至少支持 8000 个字节的请求行长度。

### 3.1.2. 状态行

响应报文的第一行是状态行，由协议版本、空格（SP）、状态代码、另一个空格、描述状态代码的可能为空的文本短语组成，并以 CRLF 结束。

```
status-line = HTTP-version SP status-code SP reason-phrase CRLF
```

status-code 部分是一个 3 位数的整数代码，描述了服务器试图理解和满足客户的相应请求的结果。响应报文的其余部分将根据为该状态代码定义的语义来解释。关于状态码的语义，包括状态码的类别（由第一个数字表示）、本规范定义的状态码、定义新状态码的注意事项以及 IANA 注册表，见[RFC 7231]的第 6 节。

```
status-code = 3DIGIT
```

Reason-phrase 部分存在的唯一目的是提供与数字状态码相关的文本描述，这主要是出于对早期互联网应用协议的尊重，这些协议更经常地用于交互式文本客户。客户应该忽略原因短语的内容。

```
reason-phrase = *( HTAB / SP / VCHAR / obs-text )
```

## 3.2. 首部字段

每个首部字段由一个不区分大小写的字段名组成，后面是冒号（":"）、可选的前导空白、字段值和可选的后导空字段名标记将相应的字段值标记为具有该首部字段所定义的语义。例如，在[RFC 7231]第 7.1.1.2 节中，Date 首部字段被定义为包含它所出现的报文的起源时间戳。白。

```
header-field = field-name ":" OWS field-value OWS

field-name = token
field-value = *( field-content / obs-fold )
field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
field-vchar = VCHAR / obs-text

obs-fold = CRLF 1*( SP / HTAB )
           ; obsolete line folding
           ; see Section 3.2.4
```

字段名标记将相应的字段值标记为具有该首部字段所定义的语义。例如，在[RFC 7231]第 7.1.1.2 节中，Date 首部字段被定义为包含它所出现的报文的起源时间戳。

### 3.2.1. 字段扩展性

首部字段是完全可扩展的：对引入新的字段名没有限制，每个字段大概都定义了新的语义，也没有限制在一个给定报文中使用的首部字段的数量。现有的字段在本规范的每个部分和本文档集以外的许多其他规范中都有定义。

新的首部字段可以被定义，当它们被接收方理解时，它们可以覆盖或加强对先前定义的首部字段的解释，定义请求评估的前提条件，或完善响应的含义。

代理 **必须** 转发未识别的首部字段，除非字段名被列在连接首部字段中（第 6.1 节），或者代理被特别配置为阻止或以其他方式转换这些字段。其他接收方 **应该** 忽略未被识别的首部字段。这些要求允许 HTTP 的功能得到增强，而不需要事先更新已部署的中介。

所有定义的首部字段都应该在 IANA 的 "报文首部" 注册表中注册，如[RFC 7231]第 8.3 节中所述。

### 3.2.2. 字段顺序

接收具有不同字段名的首部字段的顺序并不重要。然而，好的做法是先发送包含控制数据的首部字段，如请求中的 Host 和响应中的 Date，这样实现就可以尽早决定何时不处理一个报文。在收到整个请求首部区域之前，服务器不得将请求应用于目标资源，因为后来的首部字段可能包括条件、认证凭证或故意误导的重复首部字段，这将影响请求处理。

发送方 **不得** 在一条报文中生成具有相同字段名的多个首部字段，除非该首部字段的整个字段值被定义为逗号分隔的列表[即#(value)]，或者该首部字段是众所周知的例外（如下所述）。

接收方 **可以** 将具有相同字段名的多个首部字段合并为一个 "字段名：字段值" 对，而不改变报文的语义，方法是将每个后续字段值按顺序附加到合并的字段值上，用逗号分隔。因此，具有相同字段名的首部字段的接收顺序对组合字段值的解释很重要；代理在转发报文时 **不得** 改变这些字段值的顺序。

注意：在实践中，"Set-Cookie" 首部字段（[RFC 6265]）经常在响应报文中出现多次，并且不使用列表语法，违反了上述关于多个同名首部字段的要求。由于它不能被合并成一个字段值，接收方在处理首部字段时应该把 "Set-Cookie" 作为一种特殊情况来处理。(详见[Kri 2001]的附录 A.2.3）。)

### 3.2.3. 空白

本规范使用三种规则来表示线性空白的使用。OWS（可选空白）、RWS（必需空白）和 BWS（"坏"空白）。

OWS 规则用于可能出现零或更多线性空白的八位数。对于为了提高可读性而倾向于选择空白的协议元素，发送方 **应该** 将可选的空白生成为单个 SP；否则，发送方 **不应该** 生成可选的空白，除非在就地报文过滤过程中需要清除无效的或不需要的协议元素。

当至少需要一个线性空白的八位数来分隔字段标记时，就会使用 RWS 规则。发送方 **应该** 将 RWS 生成为单个 SP。

BWS 规则用于语法仅出于历史原因允许可选的空白的情况。发送方 **不应该** 在报文中生成 BWS。接收方 **必须** 在解释协议元素之前解析这种不良的空白并将其删除。

```
OWS = *( SP / HTAB )
      ; optional whitespace
RWS = 1*( SP / HTAB )
      ; required whitespace
BWS = OWS
      ; "bad" whitespace
```

### 3.2.4. 字段解析

报文是用一种通用的算法来解析的，与各个首部字段的名称无关。一个给定的字段值内的内容直到报文解释的后期阶段才会被解析（通常是在报文的整个首部区域被处理之后）。因此，本规范不使用 ABNF 规则来定义每个 "字段名。字段值" 对，就像以前的版本那样。相反，本规范使用根据每个注册的字段名命名的 ABNF 规则，其中该规则定义了该字段对应的字段值的有效语法（即，在字段-值被通用字段分析器从首部区域提取后）。

首部字段名和冒号之间不允许有空白。在过去，对这种空白处理的不同导致了请求路由和响应处理中的安全漏洞。服务器 **必须** 拒绝任何收到的、在首部字段名和冒号之间含有空格的请求报文，其响应代码为 400(Bad Request)。代理 **必须** 在向下游转发报文之前从响应报文中删除任何此类空白。

字段值前面和/或后面可能有可选的空白(OWS)；为了使人类的可读性一致，字段值前面最好有一个 SP。字段值不包括任何前面或后面的空白。在字段值的第一个非空白八位字节之前或在字段值的最后一个非空白八位字节之后出现的 OWS 应该被解析器在从首部字段中提取字段值时排除。

历史上，HTTP 首部的字段值可以通过在每一个额外的行前至少有一个空格或水平制表符（obs-fold）来扩展到多行。除了在 message/http 媒体类型中（第 8.3.1 节），本规范废除了这种折行。发送方 **不得** 生成包括折行的报文（即有任何包含与 obs-fold 规则相匹配的字段值），除非该报文打算在报文/http 媒体类型中打包。

在不在报文/http 容器内的请求报文中收到折行的服务器 **必须** 通过发送 400(Bad Request)来拒绝该报文，最好是用说明来解释折行是不可接受的，或者在解释字段值或将报文转发到下游之前用一个或多个 SP 字节来替换每个收到的折行。

代理或网关如果在不在报文/http 容器内的响应报文中收到废弃的折行，**必须** 丢弃该报文并以 502(Bad Gateway)响应代替它，最好带有解释收到不可接受的折行的表示，或者在解释字段值或向下游转发报文之前用一个或多个 SP 八位字节代替每个收到的废弃的折行。

用户代理如果在不在报文/http 容器内的响应报文中收到 obs-fold，那么在解释字段值之前，**必须** 用一个或多个 SP 八位数替换每个收到的 obs-fold。

历史上，HTTP 允许字段内容采用 ISO-8859-1 字符集[ISO-8859-1]，只通过使用[RFC 2047]编码来支持其他字符集。在实践中，大多数 HTTP 首部字段值只使用 US-ASCII 字符集[USASCII]的一个子集。新定义的首部字段应该将其字段值限制在 US-ASCII 八位数。接收方应该把字段内容（obs-text）中的其他八位字节视为不透明数据。

### 3.2.5. 字段限制

如第 2.5 节所述，HTTP 没有对每个首部字段的长度或首部区域的整体长度做出预定的限制。在实践中，对单个首部字段的长度有各种特别的限制，通常取决于具体的首部字段语义。

一个服务器如果收到的请求首部字段或字段集超过它希望处理的长度，**必须** 以适当的 4xx(Client Error)状态代码来响应。忽略这些首部字段会增加服务器对请求偷渡攻击的脆弱性（第 9.5 节）。

如果字段的语义是可以安全地忽略掉被丢弃的值而不改变报文框架或响应语义，那么客户 **可以** 丢弃或截断收到的大于客户希望处理的首部字段。

### 3.2.6. 字段值部分

大多数 HTTP 首部字段的值都是使用常见的语法组件（token、quoted-string 和 comment）来定义的，并以空格或特定的定界字符分隔。定界符是从标记中不允许的 US-ASCII 视觉字符集中选择的（DQUOTE 和"(),/:;<=>?@[\]{}"）。

```
token = 1*tchar

tchar = "!" / "#" / "$" / "%" / "&" / "’" / "*"
        / "+" / "-" / "." / "^" / "_" / "‘" / "|" / "˜"
        / DIGIT / ALPHA
        ; any VCHAR, except delimiters
```

如果一个文本字符串使用双引号引出，则被解析为一个单值。

```
quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
qdtext = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
obs-text = %x80-FF
```

注释可以包含在一些 HTTP 首部字段中，方法是用圆括号包围注释文本。注释只允许出现在包含 "注释" 的字段中，作为其字段值定义的一部分。

```
comment = "(" *( ctext / quoted-pair / comment ) ")"
ctext = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
```

反斜线八位数("/")可以作为一个单八位数的引号机制在引号字符串和注释结构中使用。处理引号字符串的值的接收方必须处理引号对，就像它被反斜杠后面的八位数取代一样。

```
quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
```

发送方不应该在一个带引号的字符串中产生一个引号对，除非在必要时引用 DQUOTE 和该字符串中出现的反斜杠八位数。发送方不应该在注释中产生一个带引号的对，除非在必要时引用括号["(" 和 ")"]和该注释中出现的反斜杠八位数。

## 3.3. 报文体

HTTP 报文的报文体（如果有的话）被用来承载该请求或响应的有效载荷体。报文体与有效载荷体是相同的，除非应用了传输编码，如第 3.3.1 节中所述。

```
message-body = *OCTET
```

对于请求和响应来说，报文体何时被允许出现在报文中的规则不同。

请求中报文体的存在是由 Content-Length 或 Transfer-Encoding 首部字段来表示的。请求报文框架与方法语义无关，即使该方法没有定义报文体的任何用途。

响应中报文体的存在取决于它所响应的请求方法和响应状态代码（第 3.1.2 节）。对 HEAD 请求方法（[RFC 7231]第 4.3.2 节）的响应从不包括报文体，因为相关的响应首部字段（例如 Transfer-Encoding、Content-Length 等），如果存在的话，只表示如果请求方法是 GET（[RFC 7231]第 4.3.1 节），它们的值会是什么。对 CONNECT 请求方法（[RFC 7231]第 4.3.6 节）的 2xx(Successful)响应切换到隧道模式，而不是有一个报文体。所有 1xx(Informational)、204(No Content)和 304(Not Modified)响应都不包括报文体。所有其他响应都包括一个报文体，尽管该报文体可能是零长度。

### 3.3.1. Transfer-Encoding

Transfer-Encoding 首部字段列出了与已经（或将要）应用于有效载荷体的传输编码序列相对应的传输编码名称，以形成报文体。传输编码的定义见第 4 节。

```
Transfer-Encoding = 1#transfer-coding
```

Transfer-Encoding 类似于 MIME 的 Content-Transfer-Encoding 字段，它被设计为在 7 位传输服务上实现二进制数据的安全传输（[RFC 2045]，第 6 节）。然而，安全传输对于一个 8 位的干净传输协议来说有不同的重点。在 HTTP 的情况下，Transfer-Encoding 主要是为了准确地划分动态生成的有效载荷，并将仅用于传输效率或安全的有效载荷编码与作为所选资源特征的编码区分开。

接收方必须能够解析分块传输编码（第 4.1 节），因为在事先不知道有效载荷体大小的情况下，它在构架报文方面起着关键作用。发送方不得对一个报文体应用分块一次以上（即不允许对已经分块的报文进行分块）。如果除 chunked 以外的任何传输编码被应用于请求有效载荷体，发送方必须应用 chunked 作为最后的传输编码，以确保报文被正确地构架。如果除 chunked 以外的任何传输编码被应用于响应有效载荷体，发送方必须应用 chunked 作为最终传输编码或通过关闭连接来终止报文。

例如：

```
Transfer-Encoding: gzip, chunked
```

表示有效载荷体已经使用 gzip 编码进行了压缩，然后在形成报文体时使用 chunked 编码进行分块。

与 Content-Encoding（[RFC 7231]第 3.1.2.1 节）不同，Transfer-Encoding 是报文的一个属性，而不是表示方法，而且沿着请求/响应链的任何接收方都 **可以** 对收到的传输编码进行解码，或者对报文体应用额外的传输编码，前提是对 Transfer-Encoding 字段值做出相应的改变。关于编码参数的其他报文可以由本规范没有定义的其他首部字段提供。

Transfer-Encoding **可以** 在对 HEAD 请求的响应中或对 GET 请求的 304(Not Modified)响应（[RFC 7232]第 4.1 节）中发送，这两个请求都不包括报文体，以表明如果该请求是无条件的 GET，起源服务器将对报文体应用传输编码。然而，这种指示是不需要的，因为响应链上的任何接收方（包括源服务器）都可以在不需要传输编码时删除它们。

服务器 **不得** 在任何状态代码为 1xx(Informational)或 204(No Content)的响应中发送传输编码首部字段。服务器 **不得** 在对 CONNECT 请求的任何 2xx(Successful)响应中发送 Transfer-Encoding 首部字段（[RFC 7231]的 4.3.6 节）。

Transfer-Encoding 是在 HTTP/1.1 中添加的。一般认为，只支持 HTTP/1.0 的实现将不理解如何处理传输编码的有效载荷。除非客户知道服务器会处理 HTTP/1.1（或更高版本）的请求，否则客户 **不得** 发送包含 Transfer-Encoding 的请求；这种通告可能是以特定的用户配置的形式，或者通过记住先前收到的响应的版本。除非相应的请求表明是 HTTP/1.1（或更高版本），否则服务器 **不得** 发送包含 Transfer-Encoding 的响应。

一个服务器如果收到一个带有它不理解的传输编码的请求报文，**应该** 以 501(Not Implemented)来响应。

### 3.3.2. Content-Length

当报文没有 Transfer-Encoding 首部字段时，Content-Length 首部字段可以为潜在的有效载荷体提供预期的大小，作为一个十进制的字节数。对于包括有效载荷体的报文，Content-Length 字段值提供了确定主体（和报文）结束位置所需的框架报文。对于不包括有效载荷体的报文，Content-Length 表示所选表示的大小（[RFC 7231]的第 3 节）。

```
Content-Length = 1*DIGIT
```

例如：

```
Content-Length: 3495
```

发送方 **不得** 在任何包含 Transfer-Encoding 首部字段的报文中发送 Content-Length 首部字段。

当没有发送 Transfer-Encoding 并且请求方法定义了所包含的有效载荷体的含义时，用户代理 **应该** 在请求报文中发送 Content-Length。例如，通常在 POST 请求中发送 Content-Length 首部字段，即使其值为 0（表示一个空的有效载荷体）。当请求报文不包含有效载荷体，并且方法语义没有预料到有这样一个体时，用户代理 **不应该** 发送 Content-Length 首部字段。

服务器 **可以** 在对 HEAD 请求的响应中发送 Content-Length 首部字段（[RFC 7231]的第 4.3.2 节）；服务器 **不得** 在这种响应中发送 Content-Length，除非它的字段值等于如果同一请求使用 GET 方法时在响应的有效载荷体中发送的十进制数。

服务器 **可以** 在对有条件的 GET 请求（[RFC 7232]第 4.1 节）的 304(Not Modified)响应中发送 Content-Length 首部字段；服务器 **不得** 在这种响应中发送 Content-Length，除非其字段值等于对同一请求的 200(OK)响应的有效载荷体中所发送的十进制数。

服务器 **不得** 在任何状态代码为 1xx(Informational)或 204(No Content)的响应中发送 Content-Length 首部字段。服务器 **不得** 在对 CONNECT 请求的任何 2xx(Successful)响应中发送 Content-Length 首部字段（[RFC 7231]的 4.3.6 节）。

除了上面定义的情况外，在没有 Transfer-Encoding 的情况下，当有效载荷体出现时，源服务器应该发送一个 Content-Length 首部字段。因为在发送完整的首部区域之前，有效载荷体的大小是已知的。这将允许下游接收方测量传输进度，知道什么时候收到的报文是完整的，并有可能为其他请求重新使用连接。

任何大于或等于零的 Content-Length 字段值都是有效的。由于对有效载荷的长度没有预定的限制，接收方必须预计到潜在的大的十进制数字，并防止由于整数转换溢出造成的解析错误（第 9.3 节）。

如果收到的报文有多个 Content-Length 首部字段，其字段值由相同的十进制数值组成，或者有一个 Content-Length 首部字段，其字段值包含一个相同的十进制数值列表（例如。"Content-Length: 42, 42"），表明上游报文处理器生成或合并了重复的 Content-Length 首部字段，那么接收方必须在确定报文正文长度或转发报文之前，以无效的方式拒绝该报文，或者用包含该十进制值的单一有效 Content-Length 字段替换重复的字段值。

注意：HTTP 在报文框架中使用 Content-Length 与 MIME 中使用同一字段有很大不同，在 MIME 中它是一个可选字段，只在 "message/external-body" 媒体类型中使用。

### 3.3.3. 报文体长度

报文体的长度由以下一项决定（按优先顺序）：

1. 任何对 HEAD 请求的响应和任何具有 1xx(Informational)、204(No Content)或 304(Not Modified)状态代码的响应总是由首部字段之后的第一个空行结束，而不管报文中存在哪些首部字段，因此不能包含报文体。
2. 任何对 CONNECT 请求的 2xx（成功）响应意味着连接将在结束首部字段的空行后立即成为隧道。客户 **必须** 忽略在这种报文中收到的任何 Content-Length 或 Transfer-Encoding 首部字段。
3. 如果有一个 Transfer-Encoding 首部字段，并且分块传输编码（第 4.1 节）是最终的编码，报文体的长度是通过读取和解码分块数据来确定的，直到传输编码表明数据已经完成。
  
如果响应中出现了 Transfer-Encoding 首部字段，并且分块传输编码不是最终编码，那么报文主体的长度是通过读取连接来确定的，直到它被服务器关闭。如果请求中存在 Transfer-Encoding 首部字段，并且分块传输编码不是最终编码，则无法可靠地确定报文主体的长度；服务器 **必须** 以 400(Bad Request)状态代码进行响应，然后关闭连接。

如果收到的报文同时带有 Transfer-Encoding 和 Content-Length 首部字段，那么 Transfer-Encoding 将覆盖 Content-Length。这样的报文可能表明试图执行请求偷渡（第 9.5 节）或响应分割（第 9.4 节），应该作为错误处理。发送方 **必须** 在向下游转发这样的报文之前删除收到的 Content-Length 字段。

4. 如果收到的报文没有 Transfer-Encoding，并且具有不同字段值的多个 Content-Length 首部字段，或者具有无效值的单个 Content-Length 首部字段，那么报文的框架是无效的，接收方 **必须** 将其视为不可恢复的错误。如果这是一个请求报文，服务器 **必须** 以 400(Bad Request)状态代码进行响应，然后关闭连接。如果这是由代理收到的响应报文，代理 **必须** 关闭与服务器的连接，丢弃收到的响应，并向客户发送 502(Bad Gateway)响应。如果这是由用户代理收到的响应报文，用户代理 **必须** 关闭与服务器的连接，并丢弃收到的响应。
5. 如果有一个有效的 Content-Length 首部字段，而没有 Transfer-Encoding，它的十进制值定义了预期的报文体长度（八位数）。如果发送方关闭连接或接收方在收到指定的八位数之前超时，接收方 **必须** 认为报文不完整并关闭连接。
6. 如果这是一个请求报文，并且上述情况都不成立，那么报文体长度为零（没有报文体存在）。
7. 否则，这是一个没有声明报文体长度的响应报文，所以报文体长度由服务器关闭连接前收到的八位数决定。

由于没有办法区分一个成功完成的、有封闭限制的报文和一个因网络故障而中断的部分接收的报文，服务器 **应该** 尽可能地生成编码或有长度限制的报文。闭合限制功能的存在主要是为了向后兼容 HTTP/1.0。

服务器 **可以** 通过响应 411(Length Required)来拒绝一个包含报文体但没有内容长度的请求。

除非已经应用了分块传输编码以外的传输编码，否则如果事先知道报文体的长度，发送包含报文体的请求的客户 **应该** 使用有效的 Content-Length 首部字段，而不是分块传输编码，因为一些现有的服务以 411(Length Required)状态代码响应分块传输，即使它们理解分块传输编码。这通常是因为这些服务是通过一个网关实现的，该网关在被调用之前需要一个内容长度，而服务器不能或不愿意在处理之前缓冲整个请求。

如果用户代理不知道服务器将处理 HTTP/1.1（或更高版本）的请求，那么发送包含报文体的请求的用户代理 **必须** 发送一个有效的 Content-Length 首部字段；这种知识可以是特定用户配置的形式，也可以是通过记住先前收到的响应的版本。

如果已经完全收到了对连接上的最后一个请求的最终响应，并且仍然有额外的数据需要读取，那么用户代理 **可以** 丢弃剩余的数据，或者试图确定该数据是否属于先前响应体的一部分，如果先前报文的 Content-Length 值不正确，就会出现这种情况。客户 **不得** 将这种额外的数据作为单独的响应进行处理、缓存或转发，因为这种行为容易导致缓存中毒。

## 3.4. 处理不完整的报文

一个服务器如果收到一个不完整的请求报文，通常是由于一个取消的请求或一个被触发的超时异常，可能会在关闭连接之前发送一个错误响应。

客户如果收到不完整的响应报文，这可能发生在连接被提前关闭的情况下，或者当解码一个所谓的分块传输编码失败时，**必须** 将该报文记录为不完整。对不完整响应的缓存要求在[RFC 7234]的第 3 节中定义。

如果响应在首部区域的中间终止（在收到空行之前），并且状态代码可能依赖于首部字段来传达响应的全部含义，那么客户不能假定该含义已被传达；客户可能需要重复请求，以确定下一步要采取什么行动。

如果没有收到终止编码的零尺寸块，使用分块传输编码的报文体是不完整的。如果收到的报文体的大小（以八位字节为单位）小于 Content-Length 给出的值，那么使用有效的 Content-Length 的报文是不完整的。一个既没有分块传输编码也没有 Content-Length 的响应因连接的关闭而终止，因此，不管收到的报文体的八位数是多少，只要标题部分被完整地收到，就被认为是完整的。

## 3.5. 报文解析健壮性

较早的HTTP/1.0用户代理实现可能会在POST请求后发送一个额外的CRLF，作为一些早期服务器应用的变通方法，这些应用无法读取没有行尾的报文体内容。HTTP/1.1用户代理不得在请求前面或后面加上一个额外的CRLF。如果需要用行结结束请求报文体，那么用户代理必须将结束的CRLF八位数算作报文体长度的一部分。

为了稳健起见，期待接收和解析请求行的服务器应该忽略在请求行之前收到的至少一个空行（CRLF）。

尽管起始行和标题字段的行结束符是CRLF序列，但接收者可以将单个LF识别为行结束符并忽略前面的CR。

尽管请求行和状态行的语法规则要求每个组成元素由单个SP八位数分隔，但接收者可以在以空格为界限的字边界上进行解析，除了CRLF结束符外，将任何形式的空格视为SP分隔符，同时忽略前面或后面的空格；这种空格包括以下一个或多个八位数。SP、HTAB、VT（%x0B）、FF（%x0C），或裸CR。然而，如果报文有多个接收者，并且每个接收者对健壮性都有自己独特的解释，那么宽松的解析会导致安全漏洞（见第9.5节）。

当一个只监听HTTP请求报文的服务器，或者在处理从起始行看来是HTTP请求报文的服务器，收到一个不符合HTTP报文语法的八进制序列，除了上面列出的健壮性例外，服务器应该以400(Bad Request)响应。

# 4. 传输编码

传输编码名称用于表示已经、可以或可能需要应用于有效载荷体的编码转换，以确保通过网络 "安全传输"。这与内容编码不同，传输编码是报文的一个属性，而不是被转移的代表的一个属性。

```
transfer-coding = "chunked" ; Section 4.1
                  / "compress" ; Section 4.2.1
                  / "deflate" ; Section 4.2.2
                  / "gzip" ; Section 4.2.3
                  / transfer-extension
transfer-extension = token *( OWS ";" OWS transfer-parameter )                 
```

参数的形式是名称或名称=值对。

```
transfer-parameter = token BWS "=" BWS ( token / quoted-string )
```

所有的传输编码名称都是不区分大小写的，并且应该在HTTP传输编码注册表中注册，如第8.4节所定义。它们被用于TE（第4.3节）和Transfer-Encoding（第3.3.1节）首部字段中。
## 4.1. 分块传输编码

分块传输编码包裹了有效载荷体，以便将其作为一系列分块进行传输，每个分块都有自己的大小指标，后面是包含首部字段的可选择的预告片。分块使未知大小的内容流能够作为一连串有长度限制的缓冲区来传输，这使发送方能够保留连接的持久性，而接收方能够知道它何时收到了整个报文。

```
chunked-body = *chunk
               last-chunk
               trailer-part
               CRLF
chunk = chunk-size [ chunk-ext ] CRLF
        chunk-data CRLF
chunk-size = 1*HEXDIG
last-chunk = 1*("0") [ chunk-ext ] CRLF

chunk-data = 1*OCTET ; a sequence of chunk-size octets
```

chunk-size字段是一串十六进制数字，表示分块数据的八位数大小。当收到一个分块大小为0的分块时，分块传输编码就完成了，后面可能还有一个trailer，最后以一个空行结束。

接收者必须能够解析和解码分块传输编码。

### 4.1.1. 块扩展

分块编码允许每个分块包括零个或多个分块扩展，紧跟在分块大小之后，以便提供每个分块的元数据（如签名或散列）、中间报文控制报文或报文体大小的随机化。

```
chunk-ext = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )

chunk-ext-name = token
chunk-ext-val = token / quoted-string
```

分块编码对每个连接都是特定的，在任何高层应用有机会检查扩展之前，每个接收者（包括中间人）都有可能被删除或重新编码。因此，分块扩展的使用通常限于专门的HTTP服务，如 "长轮询"（客户端和服务器可以对分块扩展的使用有共同的期望）或用于端到端安全连接中的填充。

接收方必须忽略未被识别的分块扩展。服务器应该将请求中收到的分块扩展的总长度限制在对所提供的服务来说是合理的，就像它对报文的其他部分应用长度限制和超时一样，如果超过了这个数量，就产生一个适当的 4xx(Client Error) 响应。

### 4.1.2. 分块 Trailer-Part

Trailer允许发送者在分块报文的末尾包括额外的字段，以便提供可能在报文主体发送时动态产生的元数据，例如报文完整性检查、数字签名或后处理状态。Trailer字段与首部字段相同，只是它们是在分块的Trailer中发送，而不是在首部部分。

```
trailer-part = *( header-field CRLF )
```

发送方不得生成包含报文分帧（如Transfer-Encoding和Content-Length）、路由（如Host）、请求修饰字段（如[RFC 7231]第5节的控制和条件）、认证（如，见[RFC 7235]和[RFC 6265]）、响应控制数据（例如，见[RFC 7231]第7.1节），或确定如何处理有效载荷（例如，内容编码、内容类型、内容范围和Trailer）。

当收到包含非空Trailer的分块报文时，接收者可以处理这些字段（除了上面禁止的字段），就像它们被附加到报文的首部区域一样。接收方必须忽略（或将其视为错误）任何禁止在Trailer中发送的字段，因为将其作为首部区域中的字段来处理可能会绕过外部安全过滤器。

除非请求包括一个TE头字段，表明 "Trailer "是可接受的，如第4.3节所述，否则服务器不应该生成它认为用户代理有必要接收的Trailer字段。如果没有包含 "Trailer "的TE，服务器应该假定Trailer字段可能在通往用户代理的路径上被默默地丢弃。这个要求允许中间人将一个去分块的消息转发给HTTP/1.0的接收者，而不需要缓冲整个响应。

### 4.1.3. 解码分块

对分块传输编码进行解码的过程可以用伪代码表示为：

```
length := 0
read chunk-size, chunk-ext (if any), and CRLF
while (chunk-size > 0) {
  read chunk-data and CRLF
  append chunk-data to decoded-body
  length := length + chunk-size
  read chunk-size, chunk-ext (if any), and CRLF
}
read trailer field
  while (trailer field is not empty) {
  if (trailer field is allowed to be sent in a trailer) {
    append trailer field to existing header fields
  }
  read trailer-field
}
Content-Length := length
Remove "chunked" from Transfer-Encoding
Remove Trailer from existing header fields
```


### 4.1.4. 压缩编码

下面定义的编码可用于压缩信息的有效载荷。

### 4.1.5. 压缩地编码

The "compress" coding is an adaptive Lempel-Ziv-Welch (LZW) coding
[Welch] that is commonly produced by the UNIX file compression
program "compress". A recipient SHOULD consider "x-compress" to be
equivalent to "compress".

### 4.1.6. 释义编码

The "deflate" coding is a "zlib" data format [RFC1950] containing a
"deflate" compressed data stream [RFC1951] that uses a combination of
the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.

Note: Some non-conformant implementations send the "deflate"
compressed data without the zlib wrapper.

### 4.1.7. Gzip 编码

The "gzip" coding is an LZ77 coding with a 32-bit Cyclic Redundancy
Check (CRC) that is commonly produced by the gzip file compression
program [RFC1952]. A recipient SHOULD consider "x-gzip" to be
equivalent to "gzip".

## 4.2. TE

The "TE" header field in a request indicates what transfer codings,
besides chunked, the client is willing to accept in response, and
whether or not the client is willing to accept trailer fields in a
chunked transfer coding.

The TE field-value consists of a comma-separated list of transfer
coding names, each allowing for optional parameters (as described in
Section 4), and/or the keyword "trailers". A client MUST NOT send
the chunked transfer coding name in TE; chunked is always acceptable
for HTTP/1.1 recipients.

```
TE = #t-codings
t-codings = "trailers" / ( transfer-coding [ t-ranking ] )
t-ranking = OWS ";" OWS "q=" rank
rank = ( "0" [ "." 0*3DIGIT ] )
      / ( "1" [ "." 0*3("0") ] )
```

Three examples of TE use are below.

TE: deflate
TE:
TE: trailers, deflate;q=0.5

The presence of the keyword "trailers" indicates that the client is
willing to accept trailer fields in a chunked transfer coding, as
defined in Section 4.1.2, on behalf of itself and any downstream
clients. For requests from an intermediary, this implies that
either: (a) all downstream clients are willing to accept trailer
fields in the forwarded response; or, (b) the intermediary will
attempt to buffer the response on behalf of downstream recipients.
Note that HTTP/1.1 does not define any means to limit the size of a
chunked response such that an intermediary can be assured of
buffering the entire response.

When multiple transfer codings are acceptable, the client MAY rank
the codings by preference using a case-insensitive "q" parameter
(similar to the qvalues used in content negotiation fields, Section
5.3.1 of [RFC7231]). The rank value is a real number in the range 0
through 1, where 0.001 is the least preferred and 1 is the most
preferred; a value of 0 means "not acceptable".

If the TE field-value is empty or if no TE field is present, the only
acceptable transfer coding is chunked. A message with no transfer
coding is always acceptable.

Since the TE header field only applies to the immediate connection, a
sender of TE MUST also send a "TE" connection option within the
Connection header field (Section 6.1) in order to prevent the TE
field from being forwarded by intermediaries that do not support its
semantics.

## 4.3. Trailer

When a message includes a message body encoded with the chunked
transfer coding and the sender desires to send metadata in the form
of trailer fields at the end of the message, the sender SHOULD
generate a Trailer header field before the message body to indicate
which fields will be present in the trailers. This allows the
recipient to prepare for receipt of that metadata before it starts
processing the body, which is useful if the message is being streamed
and the recipient wishes to confirm an integrity check on the fly.

```
Trailer = 1#field-name
```

# 5. 报文路由

HTTP request message routing is determined by each client based on
the target resource, the client’s proxy configuration, and
establishment or reuse of an inbound connection. The corresponding
response routing follows the same connection chain back to the
client.

## 5.1. 识别目标资源

HTTP is used in a wide variety of applications, ranging from
general-purpose computers to home appliances. In some cases,
communication options are hard-coded in a client’s configuration.
However, most HTTP clients rely on the same resource identification
mechanism and configuration techniques as general-purpose Web
browsers.

HTTP communication is initiated by a user agent for some purpose.
The purpose is a combination of request semantics, which are defined
in [RFC7231], and a target resource upon which to apply those
semantics. A URI reference (Section 2.7) is typically used as an
identifier for the "target resource", which a user agent would
resolve to its absolute form in order to obtain the "target URI".
The target URI excludes the reference’s fragment component, if any,
since fragment identifiers are reserved for client-side processing
([RFC3986], Section 3.5).

## 5.2. 连接入站

Once the target URI is determined, a client needs to decide whether a
network request is necessary to accomplish the desired semantics and,
if so, where that request is to be directed.

If the client has a cache [RFC7234] and the request can be satisfied
by it, then the request is usually directed there first.

If the request is not satisfied by a cache, then a typical client
will check its configuration to determine whether a proxy is to be
used to satisfy the request. Proxy configuration is implementationdependent,
but is often based on URI prefix matching, selective
authority matching, or both, and the proxy itself is usually
identified by an "http" or "https" URI. If a proxy is applicable,
the client connects inbound by establishing (or reusing) a connection
to that proxy.

If no proxy is applicable, a typical client will invoke a handler
routine, usually specific to the target URI’s scheme, to connect
directly to an authority for the target resource. How that is
accomplished is dependent on the target URI scheme and defined by its
associated specification, similar to how this specification defines
origin server access for resolution of the "http" (Section 2.7.1) and
"https" (Section 2.7.2) schemes.

HTTP requirements regarding connection management are defined in
Section 6.

## 5.3. 请求目标

Once an inbound connection is obtained, the client sends an HTTP
request message (Section 3) with a request-target derived from the
target URI. There are four distinct formats for the request-target,
depending on both the method being requested and whether the request
is to a proxy.

```
请求目标 = 原始形式
                / 绝对形式
                / 权威形式
                / 星号形式
```

### 5.3.1. 原始形式

The most common form of request-target is the origin-form.

```
原始形式 = 绝对路径 [ "?" query ]
```

When making a request directly to an origin server, other than a
CONNECT or server-wide OPTIONS request (as detailed below), a client
MUST send only the absolute path and query components of the target
URI as the request-target. If the target URI’s path component is
empty, the client MUST send "/" as the path within the origin-form of
request-target. A Host header field is also sent, as defined in
Section 5.4.

For example, a client wishing to retrieve a representation of the
resource identified as

```http
http://www.example.org/where?q=now
```

directly from the origin server would open (or reuse) a TCP
connection to port 80 of the host "www.example.org" and send the
lines:

```http
GET /where?q=now HTTP/1.1
Host: www.example.org
```

followed by the remainder of the request message.

### 5.3.2. 绝对形式

When making a request to a proxy, other than a CONNECT or server-wide
OPTIONS request (as detailed below), a client MUST send the target
URI in absolute-form as the request-target.

```
绝对形式 = absolute-URI
```

The proxy is requested to either service that request from a valid
cache, if possible, or make the same request on the client’s behalf
to either the next inbound proxy server or directly to the origin
server indicated by the request-target. Requirements on such
"forwarding" of messages are defined in Section 5.7.

An example absolute-form of request-line would be:

```http
GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
```

To allow for transition to the absolute-form for all requests in some
future version of HTTP, a server MUST accept the absolute-form in
requests, even though HTTP/1.1 clients will only send them in
requests to proxies.

### 5.3.3. 权威形式

The authority-form of request-target is only used for CONNECT
requests (Section 4.3.6 of [RFC7231]).

```
权威形式 = authority
```

When making a CONNECT request to establish a tunnel through one or
more proxies, a client MUST send only the target URI’s authority
component (excluding any userinfo and its "@" delimiter) as the
request-target. For example,

```http
CONNECT www.example.com:80 HTTP/1.1
```

### 5.3.4. 星号形式

The asterisk-form of request-target is only used for a server-wide
OPTIONS request (Section 4.3.7 of [RFC7231]).

```
星号形式 = "*"
```

When a client wishes to request OPTIONS for the server as a whole, as
opposed to a specific named resource of that server, the client MUST
send only "*" (%x2A) as the request-target. For example,

```http
OPTIONS * HTTP/1.1
```

If a proxy receives an OPTIONS request with an absolute-form of
request-target in which the URI has an empty path and no query
component, then the last proxy on the request chain MUST send a
request-target of "*" when it forwards the request to the indicated
origin server.

For example, the request

```http
OPTIONS http://www.example.org:8001 HTTP/1.1
```

would be forwarded by the final proxy as

```http
OPTIONS * HTTP/1.1
Host: www.example.org:8001
```

after connecting to port 8001 of host "www.example.org".

## 5.4. Host

The "Host" header field in a request provides the host and port
information from the target URI, enabling the origin server to
distinguish among resources while servicing requests for multiple
host names on a single IP address.

```http
Host = uri-host [ ":" port ] ; Section 2.7.1
```

A client MUST send a Host header field in all HTTP/1.1 request
messages. If the target URI includes an authority component, then a
client MUST send a field-value for Host that is identical to that
authority component, excluding any userinfo subcomponent and its "@"
delimiter (Section 2.7.1). If the authority component is missing or
undefined for the target URI, then a client MUST send a Host header
field with an empty field-value.

Since the Host field-value is critical information for handling a
request, a user agent SHOULD generate Host as the first header field
following the request-line.

For example, a GET request to the origin server for
<http://www.example.org/pub/WWW/> would begin with:


```http
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
```

A client MUST send a Host header field in an HTTP/1.1 request even if
the request-target is in the absolute-form, since this allows the
Host information to be forwarded through ancient HTTP/1.0 proxies
that might not have implemented Host.

When a proxy receives a request with an absolute-form of
request-target, the proxy MUST ignore the received Host header field
(if any) and instead replace it with the host information of the
request-target. A proxy that forwards such a request MUST generate a
new Host field-value based on the received request-target rather than
forward the received Host field-value.

Since the Host header field acts as an application-level routing
mechanism, it is a frequent target for malware seeking to poison a
shared cache or redirect a request to an unintended server. An
interception proxy is particularly vulnerable if it relies on the
Host field-value for redirecting requests to internal servers, or for
use as a cache key in a shared cache, without first verifying that
the intercepted connection is targeting a valid IP address for that
host.

A server MUST respond with a 400 (Bad Request) status code to any
HTTP/1.1 request message that lacks a Host header field and to any
request message that contains more than one Host header field or a
Host header field with an invalid field-value.

## 5.5. 有效请求URI

Since the request-target often contains only part of the user agent’s
target URI, a server reconstructs the intended target as an
"effective request URI" to properly service the request. This
reconstruction involves both the server’s local configuration and
information communicated in the request-target, Host header field,
and connection context.

For a user agent, the effective request URI is the target URI.

If the request-target is in absolute-form, the effective request URI
is the same as the request-target. Otherwise, the effective request
URI is constructed as follows:

If the server’s configuration (or outbound gateway) provides a
fixed URI scheme, that scheme is used for the effective request
URI. Otherwise, if the request is received over a TLS-secured TCP
connection, the effective request URI’s scheme is "https"; if not,
the scheme is "http".

If the server’s configuration (or outbound gateway) provides a
fixed URI authority component, that authority is used for the
effective request URI. If not, then if the request-target is in
authority-form, the effective request URI’s authority component is
the same as the request-target. If not, then if a Host header
field is supplied with a non-empty field-value, the authority
component is the same as the Host field-value. Otherwise, the
authority component is assigned the default name configured for
the server and, if the connection’s incoming TCP port number
differs from the default port for the effective request URI’s
scheme, then a colon (":") and the incoming port number (in
decimal form) are appended to the authority component.

If the request-target is in authority-form or asterisk-form, the
effective request URI’s combined path and query component is
empty. Otherwise, the combined path and query component is the
same as the request-target.

The components of the effective request URI, once determined as
above, can be combined into absolute-URI form by concatenating the
scheme, "://", authority, and combined path and query component.

Example 1: the following message received over an insecure TCP
connection

```http
GET /pub/WWW/TheProject.html HTTP/1.1
Host: www.example.org:8080
```

has an effective request URI of

```http
http://www.example.org:8080/pub/WWW/TheProject.html
```

Example 2: the following message received over a TLS-secured TCP
connection

```http
OPTIONS * HTTP/1.1
Host: www.example.org
```

has an effective request URI of https://www.example.org

Recipients of an HTTP/1.0 request that lacks a Host header field
might need to use heuristics (e.g., examination of the URI path for
something unique to a particular host) in order to guess the
effective request URI’s authority component.

Once the effective request URI has been constructed, an origin server
needs to decide whether or not to provide service for that URI via
the connection in which the request was received. For example, the
request might have been misdirected, deliberately or accidentally,
such that the information within a received request-target or Host
header field differs from the host or port upon which the connection
has been made. If the connection is from a trusted gateway, that
inconsistency might be expected; otherwise, it might indicate an
attempt to bypass security filters, trick the server into delivering
non-public content, or poison a cache. See Section 9 for security
considerations regarding message routing.

## 5.6. 将响应与请求相关联

HTTP does not include a request identifier for associating a given
request message with its corresponding one or more response messages.
Hence, it relies on the order of response arrival to correspond
exactly to the order in which requests are made on the same
connection. More than one response message per request only occurs
when one or more informational responses (1xx, see Section 6.2 of
[RFC7231]) precede a final response to the same request.

A client that has more than one outstanding request on a connection
MUST maintain a list of outstanding requests in the order sent and
MUST associate each received response message on that connection to
the highest ordered request that has not yet received a final
(non-1xx) response.

## 5.7. 报文转发

As described in Section 2.3, intermediaries can serve a variety of
roles in the processing of HTTP requests and responses. Some
intermediaries are used to improve performance or availability.
Others are used for access control or to filter content. Since an
HTTP stream has characteristics similar to a pipe-and-filter
architecture, there are no inherent limits to the extent an
intermediary can enhance (or interfere) with either direction of the
stream.

An intermediary not acting as a tunnel MUST implement the Connection
header field, as specified in Section 6.1, and exclude fields from
being forwarded that are only intended for the incoming connection.

An intermediary MUST NOT forward a message to itself unless it is
protected from an infinite request loop. In general, an intermediary
ought to recognize its own server names, including any aliases, local
variations, or literal IP addresses, and respond to such requests
directly.

### 5.7.1. Via

The "Via" header field indicates the presence of intermediate
protocols and recipients between the user agent and the server (on
requests) or between the origin server and the client (on responses),
similar to the "Received" header field in email (Section 3.6.7 of
[RFC5322]). Via can be used for tracking message forwards, avoiding
request loops, and identifying the protocol capabilities of senders
along the request/response chain.

```
Via = 1#( received-protocol RWS received-by [ RWS comment ] )

received-protocol = [ protocol-name "/" ] protocol-version
                    ; see Section 6.7
received-by = ( uri-host [ ":" port ] ) / pseudonym
pseudonym = token   
```

Multiple Via field values represent each proxy or gateway that has
forwarded the message. Each intermediary appends its own information
about how the message was received, such that the end result is
ordered according to the sequence of forwarding recipients.

A proxy MUST send an appropriate Via header field, as described
below, in each message that it forwards. An HTTP-to-HTTP gateway
MUST send an appropriate Via header field in each inbound request
message and MAY send a Via header field in forwarded response
messages.

For each intermediary, the received-protocol indicates the protocol
and protocol version used by the upstream sender of the message.
Hence, the Via field value records the advertised protocol
capabilities of the request/response chain such that they remain
visible to downstream recipients; this can be useful for determining
what backwards-incompatible features might be safe to use in
response, or within a later request, as described in Section 2.6.
For brevity, the protocol-name is omitted when the received protocol
is HTTP.

The received-by portion of the field value is normally the host and
optional port number of a recipient server or client that
subsequently forwarded the message. However, if the real host is
considered to be sensitive information, a sender MAY replace it with
a pseudonym. If a port is not provided, a recipient MAY interpret
that as meaning it was received on the default TCP port, if any, for
the received-protocol.

A sender MAY generate comments in the Via header field to identify
the software of each recipient, analogous to the User-Agent and
Server header fields. However, all comments in the Via field are
optional, and a recipient MAY remove them prior to forwarding the
message.

For example, a request message could be sent from an HTTP/1.0 user
agent to an internal proxy code-named "fred", which uses HTTP/1.1 to
forward the request to a public proxy at p.example.net, which
completes the request by forwarding it to the origin server at
www.example.com. The request received by www.example.com would then
have the following Via header field:

```http
Via: 1.0 fred, 1.1 p.example.net
```

An intermediary used as a portal through a network firewall SHOULD
NOT forward the names and ports of hosts within the firewall region
unless it is explicitly enabled to do so. If not enabled, such an
intermediary SHOULD replace each received-by host of any host behind
the firewall by an appropriate pseudonym for that host.

An intermediary MAY combine an ordered subsequence of Via header
field entries into a single such entry if the entries have identical
received-protocol values. For example,

```http
Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
```

could be collapsed to

```http
Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
```

A sender SHOULD NOT combine multiple entries unless they are all
under the same organizational control and the hosts have already been
replaced by pseudonyms. A sender MUST NOT combine entries that have
different received-protocol values.

### 5.7.2. 转译

Some intermediaries include features for transforming messages and
their payloads. A proxy might, for example, convert between image
formats in order to save cache space or to reduce the amount of
traffic on a slow link. However, operational problems might occur
when these transformations are applied to payloads intended for
critical applications, such as medical imaging or scientific data
analysis, particularly when integrity checks or digital signatures
are used to ensure that the payload received is identical to the
original.

An HTTP-to-HTTP proxy is called a "transforming proxy" if it is
designed or configured to modify messages in a semantically
meaningful way (i.e., modifications, beyond those required by normal
HTTP processing, that change the message in a way that would be
significant to the original sender or potentially significant to
downstream recipients). For example, a transforming proxy might be
acting as a shared annotation server (modifying responses to include
references to a local annotation database), a malware filter, a
format transcoder, or a privacy filter. Such transformations are
presumed to be desired by whichever client (or client organization)
selected the proxy.

If a proxy receives a request-target with a host name that is not a
fully qualified domain name, it MAY add its own domain to the host
name it received when forwarding the request. A proxy MUST NOT
change the host name if the request-target contains a fully qualified
domain name.

A proxy MUST NOT modify the "absolute-path" and "query" parts of the
received request-target when forwarding it to the next inbound
server, except as noted above to replace an empty path with "/" or
"*".

A proxy MAY modify the message body through application or removal of
a transfer coding (Section 4).

A proxy MUST NOT transform the payload (Section 3.3 of [RFC7231]) of
a message that contains a no-transform cache-control directive
(Section 5.2 of [RFC7234]).

A proxy MAY transform the payload of a message that does not contain
a no-transform cache-control directive. A proxy that transforms a
payload MUST add a Warning header field with the warn-code of 214
("Transformation Applied") if one is not already in the message (see
Section 5.5 of [RFC7234]). A proxy that transforms the payload of a
200 (OK) response can further inform downstream recipients that a
transformation has been applied by changing the response status code
to 203 (Non-Authoritative Information) (Section 6.3.4 of [RFC7231]).

A proxy SHOULD NOT modify header fields that provide information
about the endpoints of the communication chain, the resource state,
or the selected representation (other than the payload) unless the
field’s definition specifically allows such modification or the
modification is deemed necessary for privacy or security.

# 6. 连接管理

HTTP messaging is independent of the underlying transport- or
session-layer connection protocol(s). HTTP only presumes a reliable
transport with in-order delivery of requests and the corresponding
in-order delivery of responses. The mapping of HTTP request and
response structures onto the data units of an underlying transport
protocol is outside the scope of this specification.

As described in Section 5.2, the specific connection protocols to be
used for an HTTP interaction are determined by client configuration
and the target URI. For example, the "http" URI scheme
(Section 2.7.1) indicates a default connection of TCP over IP, with a
default TCP port of 80, but the client might be configured to use a
proxy via some other connection, port, or protocol.

HTTP implementations are expected to engage in connection management,
which includes maintaining the state of current connections,
establishing a new connection or reusing an existing connection,
processing messages received on a connection, detecting connection
failures, and closing each connection. Most clients maintain
multiple connections in parallel, including more than one connection
per server endpoint. Most servers are designed to maintain thousands
of concurrent connections, while controlling request queues to enable
fair use and detect denial-of-service attacks.

## 6.1. 连接

The "Connection" header field allows the sender to indicate desired
control options for the current connection. In order to avoid
confusing downstream recipients, a proxy or gateway MUST remove or
replace any received connection options before forwarding the
message.

When a header field aside from Connection is used to supply control
information for or about the current connection, the sender MUST list
the corresponding field-name within the Connection header field. A
proxy or gateway MUST parse a received Connection header field before
a message is forwarded and, for each connection-option in this field,
remove any header field(s) from the message with the same name as the
connection-option, and then remove the Connection header field itself
(or replace it with the intermediary’s own connection options for the
forwarded message).

Hence, the Connection header field provides a declarative way of
distinguishing header fields that are only intended for the immediate
recipient ("hop-by-hop") from those fields that are intended for all
recipients on the chain ("end-to-end"), enabling the message to be
self-descriptive and allowing future connection-specific extensions
to be deployed without fear that they will be blindly forwarded by
older intermediaries.

The Connection header field’s value has the following grammar:

``
Connection = 1#connection-option
connection-option = token
``

Connection options are case-insensitive.

A sender MUST NOT send a connection option corresponding to a header
field that is intended for all recipients of the payload. For
example, Cache-Control is never appropriate as a connection option
(Section 5.2 of [RFC7234]).

The connection options do not always correspond to a header field
present in the message, since a connection-specific header field
might not be needed if there are no parameters associated with a
connection option. In contrast, a connection-specific header field
that is received without a corresponding connection option usually
indicates that the field has been improperly forwarded by an
intermediary and ought to be ignored by the recipient.

When defining new connection options, specification authors ought to
survey existing header field names and ensure that the new connection
option does not share the same name as an already deployed header
field. Defining a new connection option essentially reserves that
potential field-name for carrying additional information related to
the connection option, since it would be unwise for senders to use
that field-name for anything else.

The "close" connection option is defined for a sender to signal that
this connection will be closed after completion of the response. For
example,

```http
Connection: close
```

in either the request or the response header fields indicates that
the sender is going to close the connection after the current
request/response is complete (Section 6.6).

A client that does not support persistent connections MUST send the
"close" connection option in every request message.

A server that does not support persistent connections MUST send the
"close" connection option in every response message that does not
have a 1xx (Informational) status code.

## 6.2. 建立

It is beyond the scope of this specification to describe how
connections are established via various transport- or session-layer
protocols. Each connection applies to only one transport link.

## 6.3. 持久

HTTP/1.1 defaults to the use of "persistent connections", allowing
multiple requests and responses to be carried over a single
connection. The "close" connection option is used to signal that a
connection will not persist after the current request/response. HTTP
implementations SHOULD support persistent connections.

A recipient determines whether a connection is persistent or not
based on the most recently received message’s protocol version and
Connection header field (if any):

- If the "close" connection option is present, the connection will
not persist after the current response; else,
- If the received protocol is HTTP/1.1 (or later), the connection
will persist after the current response; else,
- If the received protocol is HTTP/1.0, the "keep-alive" connection
option is present, the recipient is not a proxy, and the recipient
wishes to honor the HTTP/1.0 "keep-alive" mechanism, the
connection will persist after the current response; otherwise,
- The connection will close after the current response.

A client MAY send additional requests on a persistent connection
until it sends or receives a "close" connection option or receives an
HTTP/1.0 response without a "keep-alive" connection option.

In order to remain persistent, all messages on a connection need to
have a self-defined message length (i.e., one not defined by closure
of the connection), as described in Section 3.3. A server MUST read
the entire request message body or close the connection after sending
its response, since otherwise the remaining data on a persistent
connection would be misinterpreted as the next request. Likewise, a
client MUST read the entire response message body if it intends to
reuse the same connection for a subsequent request.

A proxy server MUST NOT maintain a persistent connection with an
HTTP/1.0 client (see Section 19.7.1 of [RFC2068] for information and
discussion of the problems with the Keep-Alive header field
implemented by many HTTP/1.0 clients).

See Appendix A.1.2 for more information on backwards compatibility
with HTTP/1.0 clients.

### 6.3.1. 重试请求

Connections can be closed at any time, with or without intention.
Implementations ought to anticipate the need to recover from
asynchronous close events.

When an inbound connection is closed prematurely, a client MAY open a
new connection and automatically retransmit an aborted sequence of
requests if all of those requests have idempotent methods (Section
4.2.2 of [RFC7231]). A proxy MUST NOT automatically retry
non-idempotent requests.

A user agent MUST NOT automatically retry a request with a nonidempotent
method unless it has some means to know that the request
semantics are actually idempotent, regardless of the method, or some
means to detect that the original request was never applied. For
example, a user agent that knows (through design or configuration)
that a POST request to a given resource is safe can repeat that
request automatically. Likewise, a user agent designed specifically
to operate on a version control repository might be able to recover
from partial failure conditions by checking the target resource
revision(s) after a failed connection, reverting or fixing any
changes that were partially applied, and then automatically retrying
the requests that failed.

A client SHOULD NOT automatically retry a failed automatic retry.

### 流水线

A client that supports persistent connections MAY "pipeline" its
requests (i.e., send multiple requests without waiting for each
response). A server MAY process a sequence of pipelined requests in
parallel if they all have safe methods (Section 4.2.1 of [RFC7231]),
but it MUST send the corresponding responses in the same order that
the requests were received.

A client that pipelines requests SHOULD retry unanswered requests if
the connection closes before it receives all of the corresponding
responses. When retrying pipelined requests after a failed
connection (a connection not explicitly closed by the server in its
last complete response), a client MUST NOT pipeline immediately after
connection establishment, since the first remaining request in the
prior pipeline might have caused an error response that can be lost
again if multiple requests are sent on a prematurely closed
connection (see the TCP reset problem described in Section 6.6).

Idempotent methods (Section 4.2.2 of [RFC7231]) are significant to
pipelining because they can be automatically retried after a
connection failure. A user agent SHOULD NOT pipeline requests after
a non-idempotent method, until the final response status code for
that method has been received, unless the user agent has a means to
detect and recover from partial failure conditions involving the
pipelined sequence.

An intermediary that receives pipelined requests MAY pipeline those
requests when forwarding them inbound, since it can rely on the
outbound user agent(s) to determine what requests can be safely
pipelined. If the inbound connection fails before receiving a
response, the pipelining intermediary MAY attempt to retry a sequence
of requests that have yet to receive a response if the requests all
have idempotent methods; otherwise, the pipelining intermediary
SHOULD forward any received responses and then close the
corresponding outbound connection(s) so that the outbound user
agent(s) can recover accordingly.

## 并发

A client ought to limit the number of simultaneous open connections
that it maintains to a given server.

Previous revisions of HTTP gave a specific number of connections as a
ceiling, but this was found to be impractical for many applications.
As a result, this specification does not mandate a particular maximum
number of connections but, instead, encourages clients to be
conservative when opening multiple connections.

Multiple connections are typically used to avoid the "head-of-line
blocking" problem, wherein a request that takes significant
server-side processing and/or has a large payload blocks subsequent
requests on the same connection. However, each connection consumes
server resources. Furthermore, using multiple connections can cause
undesirable side effects in congested networks.

Note that a server might reject traffic that it deems abusive or
characteristic of a denial-of-service attack, such as an excessive
number of open connections from a single client.

## 失败和超时

Servers will usually have some timeout value beyond which they will
no longer maintain an inactive connection. Proxy servers might make
this a higher value since it is likely that the client will be making
more connections through the same proxy server. The use of
persistent connections places no requirements on the length (or
existence) of this timeout for either the client or the server.

A client or server that wishes to time out SHOULD issue a graceful
close on the connection. Implementations SHOULD constantly monitor
open connections for a received closure signal and respond to it as
appropriate, since prompt closure of both sides of a connection
enables allocated system resources to be reclaimed.

A client, server, or proxy MAY close the transport connection at any
time. For example, a client might have started to send a new request
at the same time that the server has decided to close the "idle"
connection. From the server’s point of view, the connection is being
closed while it was idle, but from the client’s point of view, a
request is in progress.

A server SHOULD sustain persistent connections, when possible, and
allow the underlying transport’s flow-control mechanisms to resolve
temporary overloads, rather than terminate connections with the
expectation that clients will retry. The latter technique can
exacerbate network congestion.

A client sending a message body SHOULD monitor the network connection
for an error response while it is transmitting the request. If the
client sees a response that indicates the server does not wish to
receive the message body and is closing the connection, the client
SHOULD immediately cease transmitting the body and close its side of
the connection.

## 拆除

The Connection header field (Section 6.1) provides a "close"
connection option that a sender SHOULD send when it wishes to close
the connection after the current request/response pair.

A client that sends a "close" connection option MUST NOT send further
requests on that connection (after the one containing "close") and
MUST close the connection after reading the final response message
corresponding to this request.

A server that receives a "close" connection option MUST initiate a
close of the connection (see below) after it sends the final response
to the request that contained "close". The server SHOULD send a
"close" connection option in its final response on that connection.
The server MUST NOT process any further requests received on that
connection.

A server that sends a "close" connection option MUST initiate a close
of the connection (see below) after it sends the response containing
"close". The server MUST NOT process any further requests received
on that connection.

A client that receives a "close" connection option MUST cease sending
requests on that connection and close the connection after reading
the response message containing the "close"; if additional pipelined
requests had been sent on the connection, the client SHOULD NOT
assume that they will be processed by the server.

If a server performs an immediate close of a TCP connection, there is
a significant risk that the client will not be able to read the last
HTTP response. If the server receives additional data from the
client on a fully closed connection, such as another request that was
sent by the client before receiving the server’s response, the
server’s TCP stack will send a reset packet to the client;
unfortunately, the reset packet might erase the client’s
unacknowledged input buffers before they can be read and interpreted
by the client’s HTTP parser.

To avoid the TCP reset problem, servers typically close a connection
in stages. First, the server performs a half-close by closing only
the write side of the read/write connection. The server then
continues to read from the connection until it receives a
corresponding close by the client, or until the server is reasonably
certain that its own TCP stack has received the client’s
acknowledgement of the packet(s) containing the server’s last
response. Finally, the server fully closes the connection.

It is unknown whether the reset problem is exclusive to TCP or might
also be found in other transport connection protocols.

## 升级

The "Upgrade" header field is intended to provide a simple mechanism
for transitioning from HTTP/1.1 to some other protocol on the same
connection. A client MAY send a list of protocols in the Upgrade
header field of a request to invite the server to switch to one or
more of those protocols, in order of descending preference, before
sending the final response. A server MAY ignore a received Upgrade
header field if it wishes to continue using the current protocol on
that connection. Upgrade cannot be used to insist on a protocol
change.

```
Upgrade = 1#protocol

protocol = protocol-name ["/" protocol-version]
protocol-name = token
protocol-version = token
```

A server that sends a 101 (Switching Protocols) response MUST send an
Upgrade header field to indicate the new protocol(s) to which the
connection is being switched; if multiple protocol layers are being
switched, the sender MUST list the protocols in layer-ascending
order. A server MUST NOT switch to a protocol that was not indicated
by the client in the corresponding request’s Upgrade header field. A
server MAY choose to ignore the order of preference indicated by the
client and select the new protocol(s) based on other factors, such as
the nature of the request or the current load on the server.

A server that sends a 426 (Upgrade Required) response MUST send an
Upgrade header field to indicate the acceptable protocols, in order
of descending preference.

A server MAY send an Upgrade header field in any other response to
advertise that it implements support for upgrading to the listed
protocols, in order of descending preference, when appropriate for a
future request.

The following is a hypothetical example sent by a client:

```http
GET /hello.txt HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
```

The capabilities and nature of the application-level communication
after the protocol change is entirely dependent upon the new
protocol(s) chosen. However, immediately after sending the 101
(Switching Protocols) response, the server is expected to continue
responding to the original request as if it had received its
equivalent within the new protocol (i.e., the server still has an
outstanding request to satisfy after the protocol has been changed,
and is expected to do so without requiring the request to be
repeated).

For example, if the Upgrade header field is received in a GET request
and the server decides to switch protocols, it first responds with a
101 (Switching Protocols) message in HTTP/1.1 and then immediately
follows that with the new protocol’s equivalent of a response to a
GET on the target resource. This allows a connection to be upgraded
to protocols with the same semantics as HTTP without the latency cost
of an additional round trip. A server MUST NOT switch protocols
unless the received message semantics can be honored by the new
protocol; an OPTIONS request can be honored by any protocol.

The following is an example response to the above hypothetical
request:

```http
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: HTTP/2.0

[... data stream switches to HTTP/2.0 with an appropriate response
(as defined by new protocol) to the "GET /hello.txt" request ...]
```

When Upgrade is sent, the sender MUST also send a Connection header
field (Section 6.1) that contains an "upgrade" connection option, in
order to prevent Upgrade from being accidentally forwarded by
intermediaries that might not implement the listed protocols. A
server MUST ignore an Upgrade header field that is received in an
HTTP/1.0 request.

A client cannot begin using an upgraded protocol on the connection
until it has completely sent the request message (i.e., the client
can’t change the protocol it is sending in the middle of a message).
If a server receives both an Upgrade and an Expect header field with
the "100-continue" expectation (Section 5.1.1 of [RFC7231]), the
server MUST send a 100 (Continue) response before sending a 101
(Switching Protocols) response.

The Upgrade header field only applies to switching protocols on top
of the existing connection; it cannot be used to switch the
underlying connection (transport) protocol, nor to switch the
existing communication to a different connection. For those
purposes, it is more appropriate to use a 3xx (Redirection) response
(Section 6.4 of [RFC7231]).

This specification only defines the protocol name "HTTP" for use by
the family of Hypertext Transfer Protocols, as defined by the HTTP
version rules of Section 2.6 and future updates to this
specification. Additional tokens ought to be registered with IANA
using the registration procedure defined in Section 8.6.
