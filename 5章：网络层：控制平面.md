**目录：**

- [5. 网络层：控制平面](#5-网络层控制平面)
  - [5.1. 概述](#51-概述)
  - [5.2. 路由算法](#52-路由算法)
    - [5.2.1. 链路状态(LS)路由算法](#521-链路状态ls路由算法)
    - [5.2.2. 距离向量(DV)路由算法](#522-距离向量dv路由算法)
  - [5.3. 因特网中自治系统内部的路由选择：OSPF](#53-因特网中自治系统内部的路由选择ospf)
  - [5.4. ISP 之间的路由选择：BGP](#54-isp-之间的路由选择bgp)
  - [5.5. SDN 控制平面](#55-sdn-控制平面)
  - [5.6. ICMP：因特网控制报文协议](#56-icmp因特网控制报文协议)
  - [5.7. 网络管理和 SNMP](#57-网络管理和-snmp)

# 5. 网络层：控制平面

**time : 2021-06-20**

在这一章中，我们讨论网络层剩余的部分内容：**控制平面**。控制平面不仅控制着一个数据报是怎么沿着源主机到目的地主机的路径进行路由，还控制着网络层的组成部分和服务是怎么配置和管理的。在 5-2 节我们会讨论在一些传统的路由算法，这些算法类似于图论中的最短路算法。这些算法是 Internet 中被广泛使用的路由协议：OSPF 和 BGP 的基础。这两个协议我们将在 5-3 节和 5-4 节中分别讨论。我们将了解到，OSPF 协议适用于一个单独的 ISP 网络，而 BGP 协议适用于 Internet 中的所有网络。BGP 经常被称为 Internet 的粘合剂。传统上，控制平面的路由协议和数据平面的转发功能被一起实现在一个路由器中。我们在第 4 章了解到 SDN 可以使得控制面板和数据面板分开，控制面板被实现在一个远程的控制器中，而转发功能依然实现在路由器中。我们将在 5-5 节讨论 SDN。

在第 5-6 和 5-7 章节，我们将会讨论管理 IP 的 2 个协议：Internet 控制报文协议(Internet Control Message Protocol, ICMP)和简单网络管理协议(Simple Network Management Protocol, SNMP)。

## 5.1. 概述

通过回顾图 4-2 和 4-3 我们可以快速地进入这一章讨论的背景。在上一章中，我们可以看到转发表(基于目的地的转发)和流表
(通用转发)将网络层的数据和控制面板联系了起来。我们了解到这些表指定了一个路由的本地转发行为。我们看到在通用转发的情况下，流表不仅可以转发分组到一个指定的输出端口，还可以丢弃分组，复制分组，以及重写 2，3，4 层的分组首部。

在这一章，我们将学习这些表是怎么生成，维护和安装的，在 4-1 节的介绍中，我们了解到有 2 种方法：

- **路由器控制**。图 5-1 演示了一个路由算法运行在每个路由器中。转发和路由功能被实现在每一个路由器中。每个路由器都有一个转发部件，这个转发部件和其他路由器中的转发部件通信来计算生成转发表。这种路由器控制的方法在 Internet 中被使用了几十年，我们将在 5-3 和 5-4 节学习的 OSPF 和 BGP 算法就是基于路由器控制。

![/5-1-每路由器控制](illustrations/5-1-每路由器控制.png)

- **逻辑中心控制**。图 5-2 演示了逻辑中心控制的情况。在这种情况下，一个逻辑中心控制器计算并分发转发表到每一个路由器。我们在 4-4 和 4-5 节了解到通用转发不仅可以起到转发功能，而且还具有其他一些的丰富功能，例如防火墙和 NAT。

![5-2-逻辑集中式控制](illustrations/5-2-逻辑集中式控制.png)

这个控制器和每一个路由器中的 **控制代理(Control Agent, CA)** 交互，具体来讲，控制器通过一种被定义好的协议来配置和管理路由器中的流表。一般来说，控制代理只起到最基本的功能，即和控制器通信。和图 5-1 中的路由算法不同，控制代理不和其他路由器的控制代理交互，也不参与计算转发表。这是路由器控制和逻辑中心控制的关键区别。

“逻辑集中式”控制的意思是，中心的控制器可能由很多个服务器实现，但从他们提供的路由服务来看，逻辑上就是一个中心。我们将在 5-5 节看到，SDN 采用了这种逻辑中心控制，这种方法得到越来越多的应用。谷歌在它的内部 B4 全球广域网中使用了 SDN 控制路由器，该广域网互联了它的数据中心［Jain 2013］。来自微软研究院的 SWAN［Hong 2013］，使用了一个逻辑集中式控制器来管理广域网和数据中心网络之间的路由选择和转发。大部分 ISP 提供商在积极地采用和部署 SDN。我们将在第 8 章看到，4G 和 5G 蜂窝网络采用了 SDN 控制。中国电信和中国联通在它们的数据中心内以及数据中心之间使用 SDN［Li 2015]。

## 5.2. 路由算法

在本节中，我们学习 **路由算法(routing algorithm)**，路由算法是从发送方到接收方的众多路径中确定一条通过路由器网络的好的路径（等价于路由）。通常，一条好路径指的是最低开销路径。然而我们将看到，实践中现实世界还关心诸如策略之类的问题（例如，有一个规则是“属于组织 Y 的路由器 X 不应转发任何来源于组织 Z 所属网络的分组”）。我们注意到无论网络控制平面采用每路由器控制方法，还是采用逻辑集中式控制方法，必定总是存在一条定义良好的一连串路由器，使得分组从发送主机到接收主机跨越网络“旅行”。因此，计算这些路径的路由选择算法是十分重要的，是 10 个十分重要的网络问题之一。

我们可以用“图”这一概念来抽象路由问题。我们知道 **图(Graph)**：G = (N, E) 是一个 N 个节点和 E 条边的集合。其中每条边是取自 N 的一对节点。在网络层路由问题中，路由器被抽象为节点，这是做出分组转发决定的点，中间的物理链路被抽象为边，你可以看 5-3 所示的一个例子。若要查看某些表示实际网络的图，参见［Dodge 2016； Cheswick 2000］；对于基于不同的图模型建模因特网的好坏的讨论，参见［Zegura 1997 ； Faloutsos 1999 ； Li 2004］。

如图 5-3 所示，一条边还有一个值表示它的开销。显然，这是一个有权图。通常，一条边的开销可反映出对应链路的物
理长度（例如一条越洋链路的开销可能比一条短途陆地链路的开销高），它的链路速度，或与该链 路相关的金钱上的开销。为了我们的目的，我们只将这些链路开销看成是给定的，而不必操心这些值是如何确定的。对于 E 中的任一条边 `(x, y)`，我们用 `c(x, y)` 表示节点 x 和 y 间边的开销。如果节点对 (x, y）不属于 E，则 `c(x, y) = 正无穷`。 此外，我们在这里考虑的都是无向图（即图的边没有方向），因此边 (x, y) 与边(y, x)是相同的并且 c(x, y) = c(y, x)。然而，我们将学习的算法能够很容易地扩展到在每个方向有不同开销的有向图。如果(x, y) 属于 E，节点 y 也被称为节点 x 的 **邻接节点(neighbor)**。

![一个计算机网络被抽象为图](illustrations/5-3-一个计算机网络被抽象为图.png)

在图抽象中为各条边指定了开销后，路由选择算法的目标就是找岀从源到目的地间的最低开销路径。为了使问题更为精确，回想在图 `G = (N, E)`中的一条 **路径(path)** 是一个节点序列 `(x1, x2, ..., xp)`，这样每一个对 `(x1, x2)，(x2, x3), ..., (x p-1, xp)` 是 E 中的边。路径 (x1, x2, ..., xp) 的开销就是沿着路径所有边的开销的总和，即 `c(x1, X2) + c(x2, x3) + ... + c(x p-1, xp)`。给定任何两个节点 x 和 y，一般在这两个节点之间有许多条路径，每条路径都有一个开销。这些路径中的一条(或多条)为最低开销路径(least-cost path)。因此最低开销路径问题很显然是：找出源和目的地之间具有最低开销的一条路经。例如，在图 5-3 中，源节点 u 和目的节点 w 之间的最低开销路径是(u, x, y, w)，具有的路径开销是 3。注意到若在图中的所有边具有相同的开销，则最低开销路径也就是 **最短路径(shortest path)**，即在源和目的地之间的具有最少链路数量的路径。

作为一个简单练习，试找出图 5-3 中从节点 u 到节点 z 的最低开销路径，并要反映出你是如何算出该路径的。如果你像大多数人一样，通过考察图 5-3，跟踪几条从 u 到 z 的路由，你就能找出从 u 到 z 的路径，然后以某种方式来确信你所选择的路径就是所有可能的路径中具有最低开销的路径。（你考察过 u 到 z 之间的所有 17 条可能的路径吗？很可能没有！）这种计算就是一种集中式路由选择算法的例子，即路由选择算法在一个位置（你的大脑中）运行，该位置具有网络的完整信息。一般而言，路由选择算法的一种分类方式是根据该算法是集中式还是分散式来划分。

- **集中式路由选择算法(centralized routing algorithm)** 用完整的、全局性的网络信息计算岀从源到目的地之间的最低开销路径。也就是说，该算法以所有节点之间的连通性及所有链路的开销为输入。这就要求该算法在真正开始计算以前，要以某 种方式获得这些信息。计算本身可在某个场点（例如，图 5-2 中所示的逻辑集中式控制器）进行，或在每台路由器的路由选择组件中重复进行（例如在图 5-1 中）。然而，这里的主要区别在于，集中式算法具有关于连通性和链路开销方面的完整信息。具有全局状态信息的算法常被称作 **链路状态(Link State, LS)算法**，因为该算法必须知道网络中每条链路的开销。我们将在 5-2-1 节中学习 LS 算法。
- 在 **分散式路由选择算法(decentralized routing algorithm)** 中，路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息。相反，每个节点仅有与其直接相连链路的开销知识即可开始工作。然后，通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径。我们将在后面的 5-2-2 节学习一个称为 **距离向量(Distance-Vector, DV)算法** 的分散式路由选择算法。之所以叫作 DV 算法，是因为每个节点维护到网络中所有其他节点的开销（距离）估计的向量。这种分散式算法，通过相邻路由器之间的交互式报文交换，更为适合路由器直接交互的控制平面，就像在图 5-1 中那样。

路由选择算法的第二种广义分类方式是根据算法是静态的还是动态的进行分类。在 **静态路由选择算法(static routing algorithm)** 中，路由随时间的变化非常缓慢，通常是人为进行调整（如人为手工编辑一条链路开销）。**动态路由选择算法(dynamic routing algorithm)** 随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性地运行或直接响应拓扑或链路开销的变化而运行。虽然动态算法易于对网络的变化做岀反应，但也更容易受诸如路由选择循环、路由振荡之类问题的影响。

路由选择算法的第三种分类方式是根据它是负载敏感的还是负载迟钝的进行划分。在 **负载敏感算法(load-sensitive algorithm)** 中，链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该拥塞链路来选择路由。而早期的 ARPAnet 路由选择算法就是负载敏感的[McQuillan 1980]，所以遇到了许多难题[Huitema 1998]。当今的因特网路由选择算法（如 RIP、OSPF 和 BGP）都是 **负载迟钝的(load-insensitive)**，因为某条链路的开销不明确地反映其当前（或最近）的拥塞水平。

### 5.2.1. 链路状态(LS)路由算法

前面讲过，在链路状态算法中，网络拓扑和所有的链路开销都是已知的，也就是说可用作 LS 算法的输入。实践中这是通过让每个节点向网络中所有其他节点广播链路状态分 组来完成的，其中每个链路状态分组包含它所连接的链路的标识和开销。在实践中（例如 使用因特网的 OSPF 路由选择协议，讨论见 5-3 节），这经常由 **链路状态广播(link state broadcast)算法**［Perhnan 1999］来完成。节点广播的结果是所有节点都具有该网络的 一、完整的视图。于是每个节点都能够像其他节点一样，运行 LS 算法并计算出相同的最低开销路径集合。

我们下面给出的链路状态路由选择算法叫作 Dijkstra 算法，该算法以其发明者命名。一个密切相关的算法是 Prim 算法，有关图算法的一般性讨论参见［Cormen 2001］。Dijkstra 算法计算从某节点（源节点，我们称之为 u）到网络中所有其他节点的最低开销路径。Dijkstra 算法是迭代算法，其特点是经算法的第 k 次迭代后，可以计算出 k 个目的节点的最低开销路径，我们定义下列记号。

- D(v)：这次迭代中从源节点到目的节点 v 的最低开销。
- p(v)：在源节点到 v 的最低开销路径上，v 的前一个邻接节点。
- N'：图中所有节点的子集。如果源节点到 v 为最低开销路径，则 N' 包含 v。

该集中式路由选择算法由一个初始化步骤和其后的循环组成。循环执行的次数与图的节点数相等。一旦终止，该算法就得出了从源节点 u 到图中其他每个节点的最短低开销路径。

**源节点 u 的链路状态(LS)算法**

```py
1 初始化
2 N' = {u}
3 for 所有节点 v:
4  if v 是 u 的邻接节点:
5    D(v) = c(u, v)
6  else D(v) = 正无穷
7
8 循环
9    寻找一个不在 N' 中的，且 D(w) 为最小的节点 w
10   将 w 添加到 N' 中
11   对所有不在 N' 中的 w 的邻接节点 v 更新 D(v):
12     D(v) = min(D(v), D(w) + c(w, v))
13   /* 到 v 的新的开销要么是原来的 D(v)，要么是已知的到 w 的最小开销加上 w 到 v 的开销 */
14 直到 N' = N
```

举一个例子，考虑图 5-3 中的网络，计算从 u 到所有可能目的地的最低开销路径。该算法的计算过程以表格方式总结于下表中，表中的每一行给岀了迭代结束时该算法的变量的值。我们详细地考虑前几个步骤。

| 步骤 | N'     | D(v), p(v) | D(w), p(w) | D(x), p(x) | D(y), p(y) | D(z), p(z) |
| ---- | ------ | ---------- | ---------- | ---------- | ---------- | ---------- |
| 0    | u      | 2, u       | 5, u       | 1, u       | 正无穷     | 正无穷     |
| 1    | ux     | 2, u       | 4, x       |            | 2, x       | 正无穷     |
| 2    | uxy    | 2, u       | 3, y       |            |            | 4, y       |
| 3    | uxyv   |            | 3, y       |            |            | 4, y       |
| 4    | uxyvw  |            |            |            |            | 4, y       |
| 5    | uxyvwz |            |            |            |            |            |

- 在初始化步骤，从 u 到它的邻接节点 v，x，w 的最低开销路径分别初始化为 2、1 和 5。特别值得注意的是，到 w 的开销被设为 5（尽管我们很快就会看见确实存在一条开销更小的路径），因为这是从 u 到 w 的直接（一跳）链路开销。到 y 与 z 的开销被设为无穷大，因为它们不直接与 u 连接。
- 在第一次迭代中，我们观察那些还未加到集合 N' 中的节点，并且找岀在前一次迭代结束时具有最低开销的节点。那个节点便是 x，其开销是 1，因此 x 被加到集合 N' 中。于是 LS 算法更新所有节点 v 的 D(v)），产生上面的表中第 2 行（步骤 1）所示的结果。到 v 的路径开销未变。经过节点 x 到 w（在初始化结束时其开销为 5）的路径开销被发现为 4。因此这条具有更低开销的路径被选中，且沿从"开始的最短路径上"的前一节点被设为 x。类似地，到 y（经过 x）的开销被计算为 2，且该表也被相应地更新。
- 在第二次迭代时，节点 v 与 y 被发现具有最低开销路径（2），并且我们任意改变次序将 y 加到集合 N' 中，使得 N' 中含有 u、x 和 y。到仍不在 N' 中的其余节点（即节点 v， w 和 z）的开销通过 LS 算法中的第 12 行进行更新，产生如表 5-1 中第 3 行所示的结果。
- 如此等等。

当 LS 算法终止时，对于每个节点，我们都得到从源节点沿着它的最低开销路径的前一节点。对于每个前一节点，我们又有它的前一节点，以此方式我们可以构建从源节点到所有目的节点的完整路径。通过对每个目的节点存放从 u 到目的地的最低开销路径上的下一跳节点，在一个节点（如节点 u）中的转发表则能够根据此信息而构建。图 5-4 显示了对于图 5-3 中 的网络产生的最低开销路径和 u 中的转发表。

![5-4-对于节点u的最低开销路径和转发表](illustrations/5-4-对于节点u的最低开销路径和转发表.png)

该算法的计算复杂度是多少？即给定 n 个节点（不算源节点），在最坏情况下要经过多少次计算，才能找到从源节点到所有目的节点的最低开销路径？在第一次迭代中，我们需要搜索所有的 n 个节点以确定出不在 N'中且具有最低开销的节点 w。在第二次迭代时，我们需要检查 n-1 个节点以确定最低开销。第三次对 n-2 个节点迭代，依次类推。总之，我们在所有迭代中需要搜寻的节点总数为 `n*(n + 1)/2`，因此我们说前面实现的链路状态算法在最差情况下复杂性为 O(n^2)。（该算法的一种更复杂的实现是使用一种称为堆的数据结构，能用对数时间而不是线性时间得到第 9 行的最小值，因而减少其复杂性。）

**time : 2021-06-23**

在完成 LS 算法的讨论之前，我们考虑一下可能出现的问题。图 5-5 显示了一个简单的网络拓扑，图中的链路开销等于链路上承载的负载，例如反映要历经的时延。在该例中，链路开销是非对称的，即仅当在链路 c(u, v) 两个方向所承载的负载相同时 c(u, v) 与 c(v, u) 才相等。在该例中节点 z 产生发往 m 的一个单元的流量，节点 x 也产生发往 w 的一个单元的流量，并且节点 y 也产生发往 w 的一个数量为 e 的流量。初始路由选择情况如图 5-5a 所示，其链路开销对应于承载的流量。

![5-5-拥塞敏感的路由选择的振荡](illustrations/5-5-拥塞敏感的路由选择的振荡.png)

当 LS 算法再次运行时，节点 y 确定（基于图 5-5a 所示的链路开销）顺时针到 w 的路径开销为 1，而逆时针到 w 的路径开销（一直使用的）是 1+e。因此 y 到 w 的最低开销路径现在是顺时针的。类似地，x 确定其到 w 的新的最低开销路径也是顺时针的，产生如图 5-5b 中所示的开销。当 LS 算法下次运行时，节点 x、y 和 z 都检测到一条至 w 的逆时针方向零开销路径，它们都将其流量引导到逆时针方向的路由上。下次 LS 算法运行时，x、y 和 z 都将其流量引导到顺时针方向的路由上。

如何才能防止这样的振荡（它不只是出现在链路状态算法中，而且也可能出现在任何使用拥塞或基于时延的链路测度的算法中）。一种解决方案可能强制链路开销不依赖于所承载的流量，但那是一种不可接受的解决方案，因为路由选择的目标之一就是要避开高度拥塞（如高时延）的链路。另一种解决方案就是确保并非所有的路由器都同时运行 LS 算法。这似乎是一个更合理的方案，因为我们希望即使路由器以相同周期运行 LS 算法，在每个节点上算法执行的时机也将是不同的。有趣的是，研究人员近来已注意到了因特网上的路由器能在它们之间进行自同步［Floyd Synchronization 1994］。这就是说，即使它们初始时以同一周期但在不同时刻执行算法，算法执行时机最终会在路由器上变为同步并保持之。避免这种自同步的一种方法是，让每台路由器发送链路通告的时间随机化。

学习过 LS 算法之后，我们接下来考虑目前在实践中使用的其他重要的路由选择算法，即距离向量路由选择算法。

### 5.2.2. 距离向量(DV)路由算法

**距离向量(Distance-Vector, DV)** 算法是一种迭代的、异步的和分布式的算法，而 LS 算法是一种使用全局信息的算法。说它是分布式的，是因为每个节点都要从一个或多个邻接节点接收某些信息，执行计算，然后将其计算结果分发给邻接节点。说它是迭代的，是因为此过程一直要持续到邻接节点之间无更多信息要交换为止。（有趣的是，此算法是自我终止的，即没有计算应该停止的信号，它就停止了。）说它是异步的，是因为它不要求所有 节点相互之间步伐一致地操作。我们将看到一个异步的、迭代的、自我终止的、分布式的算法比一个集中式的算法要有趣得多！

在我们给岀 DV 算法之前，有必要讨论一下存在于最低开销路径的开销之间的一种重要关系。令 d(x, y) 是从节点 x 到节点 y 的最低开销路径的开销。则该最低开销与著名的 Bellman-Ford 方程相关，即

```
d(x, y) = min(v) { c(x, v) + d(v, y) }
```

方程中的 min(v) 是对于 x 的所有邻接节点的。Bellman-Ford 方程是相当直观的。实际上，从 x 到 v 遍历之后，如果我们接下来取从 v 到 y 的最低开销路径，则该路径开销将是 c(x, v) + d(v, y)。因此我们必须通过遍历某些邻接节点 v 开始，从 x 到 y 的最低开销是对所有邻接节点 v 的 c(x, v) + d(v, y) 的最小值。

我们验证在图 5-3 中的源节点 u 和目的节点 z。源节点 u 有 3 个邻接节点：v，x 和 w。通过遍历该图中的各条路径，容易看出 d(v, z) = 5，d(x, z) = 3，d(w, z) = 3。将这些值连同开销 c(u, v) = 2，c(u, x) = 1 和 c(u, w) = 5 代入上面的方程中，得出 d(u, z) = min {2+5, 5+3, 1+3} = 4，这显然是正确的，并且对同一个网络来说，这正是 Dijkstra 算法为我们提供的结果。这种快速验证应当有助于消除你可能具有的任何怀疑。

Bellman-Ford 方程实际上具有重大的实践重要性。具体来说，Bellman-Ford 方程的解为节点 x 的转发表提供了表项。为了理解这一点，令 v* 是取得该方程中最小值的任何邻接节点。接下来，如果节点 x 要沿着最低开销路径向节点 y 发送一个分组，它应当首先向节点 v* 转发该分组。因此，节点 x 的转发表将指定节点 v\* 作为最终目的地 y 的下一跳路由器。Bellman-Ford 方程的另一个重要实际贡献是，它提出了在 DV 算法中邻接节点之间的通信方式。

其基本思想如下。每个节点 x 以 D(x, y)开始，对在 N 中的所有节点 y，估计从 x 到 y 的最低开销路径的开销。令 `D(x) = [D(x, y) | y 属于 N]` 是节点 x 的距离向量，该向量是从 x 到在 N 中的所有其他节点 y 的开销估计向量。使用 DV 算法，每个节点 x 持有下列路由选择信息：

- 对于每个邻接节点 v，从 x 到邻接节点 v 的开销为 c(x, v)。
- 节点兀的距离向量，即 `D(x) = [D(x, y) | y 属于 N]`，包含了 x 到 N 中所有目的地 y 的开销估计值。
- 它的每个邻接节点的距离向量，即对 x 的每个邻接节点有 `D(v) = [D(v, y) | y 属于 N]`。

在该分布式、异步算法中，每个节点不时地向它的每个邻接发送它的距离向量副本。 当节点 x 从它的任何一个邻接节点 v 接收到一个新距离向量，它保存 v 的距离向量，然后使用 Bellman-Ford 方程更新它自己的距离向量如下：

```
D(x, y) = min(v){c(x, v), D(v, y)} 对 N 中的每个节点
```

如果节点 x 的距离向量因这个更新步骤而改变，节点 x 接下来将向它的每个邻接节点发送其更新后的距离向量，这继而让所有邻接节点更新它们自己的距离向量。令人惊奇的是，只要所有的节点继续以异步方式交换它们的距离向量，每个开销估计 D(x, y) 收敛到 d(x, y)，d(x, y) 为从节点 x 到节点 y 的实际最低开销路径的开销［Bersekas 1991］!

**距离向量(DV)算法**

在每个节点 x:

```py
1 初始化
2 for (y in N):
3   D(x, y) = c(x, y) /* 如果 y 不是邻接节点，则 c(x, y) = 正无穷 */
4 for 每一个 w:
5   D(w, y) = ? 对于所有在 N 中的目的节点 y
6 for 每一个 w:
7   向 w 发送距离向量 D(x) = [D(x, y), y 属于 N]
8
9 循环
10   等待直至 到邻接节点 w 的链路的开销改变 
11   或 收到邻接节点 w 的距离向量
12
13   for (y in N):
14     D(x, y) = min(v) { c(x, v), D(v ,y)}
15
16 if (对于任何的目的节点 y，D(x, y) 改变了):
17   向所有邻接节点发送距离向量 D(x) = [D(x, y), y 属于 N]
18
19 永远循环
```



## 5.3. 因特网中自治系统内部的路由选择：OSPF

## 5.4. ISP 之间的路由选择：BGP

## 5.5. SDN 控制平面

## 5.6. ICMP：因特网控制报文协议

## 5.7. 网络管理和 SNMP
