**目录：**

- [5. 网络层：控制平面](#5-网络层控制平面)
  - [5.1. 概述](#51-概述)
  - [5.2. 路由算法](#52-路由算法)
    - [5.2.1. 链路状态(LS)路由算法](#521-链路状态ls路由算法)
    - [5.2.2. 距离向量(DV)路由算法](#522-距离向量dv路由算法)
  - [5.3. 因特网中自治系统内部的路由选择：OSPF](#53-因特网中自治系统内部的路由选择ospf)
  - [5.4. ISP 之间的路由选择：BGP](#54-isp-之间的路由选择bgp)
  - [5.5. SDN 控制平面](#55-sdn-控制平面)
  - [5.6. ICMP：因特网控制报文协议](#56-icmp因特网控制报文协议)
  - [5.7. 网络管理和 SNMP](#57-网络管理和-snmp)

# 5. 网络层：控制平面

**time : 2021-06-20**

在这一章中，我们讨论网络层剩余的部分内容：**控制平面**。控制平面不仅控制着一个数据报是怎么沿着源主机到目的地主机的路径进行路由，还控制着网络层的组成部分和服务是怎么配置和管理的。在 5-2 节我们会讨论在一些传统的路由算法，这些算法类似于图论中的最短路算法。这些算法是 Internet 中被广泛使用的路由协议：OSPF 和 BGP 的基础。这两个协议我们将在 5-3 节和 5-4 节中分别讨论。我们将了解到，OSPF 协议适用于一个单独的 ISP 网络，而 BGP 协议适用于 Internet 中的所有网络。BGP 经常被称为 Internet 的粘合剂。传统上，控制平面的路由协议和数据平面的转发功能被一起实现在一个路由器中。我们在第 4 章了解到 SDN 可以使得控制面板和数据面板分开，控制面板被实现在一个远程的控制器中，而转发功能依然实现在路由器中。我们将在 5-5 节讨论 SDN。

在第 5-6 和 5-7 章节，我们将会讨论管理 IP 的 2 个协议：Internet 控制报文协议(Internet Control Message Protocol, ICMP)和简单网络管理协议(Simple Network Management Protocol, SNMP)。

## 5.1. 概述

通过回顾图 4-2 和 4-3 我们可以快速地进入这一章讨论的背景。在上一章中，我们可以看到转发表(基于目的地的转发)和流表
(通用转发)将网络层的数据和控制面板联系了起来。我们了解到这些表指定了一个路由的本地转发行为。我们看到在通用转发的情况下，流表不仅可以转发分组到一个指定的输出端口，还可以丢弃分组，复制分组，以及重写 2，3，4 层的分组首部。

在这一章，我们将学习这些表是怎么生成，维护和安装的，在 4-1 节的介绍中，我们了解到有 2 种方法：

- **路由器控制**。图 5-1 演示了一个路由算法运行在每个路由器中。转发和路由功能被实现在每一个路由器中。每个路由器都有一个转发部件，这个转发部件和其他路由器中的转发部件通信来计算生成转发表。这种路由器控制的方法在 Internet 中被使用了几十年，我们将在 5-3 和 5-4 节学习的 OSPF 和 BGP 算法就是基于路由器控制。

![/5-1-每路由器控制](illustrations/5-1-每路由器控制.png)

- **逻辑中心控制**。图 5-2 演示了逻辑中心控制的情况。在这种情况下，一个逻辑中心控制器计算并分发转发表到每一个路由器。我们在 4-4 和 4-5 节了解到通用转发不仅可以起到转发功能，而且还具有其他一些的丰富功能，例如防火墙和 NAT。

![5-2-逻辑集中式控制](illustrations/5-2-逻辑集中式控制.png)

这个控制器和每一个路由器中的 **控制代理(Control Agent, CA)** 交互，具体来讲，控制器通过一种被定义好的协议来配置和管理路由器中的流表。一般来说，控制代理只起到最基本的功能，即和控制器通信。和图 5-1 中的路由算法不同，控制代理不和其他路由器的控制代理交互，也不参与计算转发表。这是路由器控制和逻辑中心控制的关键区别。

“逻辑集中式”控制的意思是，中心的控制器可能由很多个服务器实现，但从他们提供的路由服务来看，逻辑上就是一个中心。我们将在 5-5 节看到，SDN 采用了这种逻辑中心控制，这种方法得到越来越多的应用。谷歌在它的内部 B4 全球广域网中使用了 SDN 控制路由器，该广域网互联了它的数据中心［Jain 2013］。来自微软研究院的 SWAN［Hong 2013］，使用了一个逻辑集中式控制器来管理广域网和数据中心网络之间的路由选择和转发。大部分 ISP 提供商在积极地采用和部署 SDN。我们将在第 8 章看到，4G 和 5G 蜂窝网络采用了 SDN 控制。中国电信和中国联通在它们的数据中心内以及数据中心之间使用 SDN［Li 2015]。

## 5.2. 路由算法

在本节中，我们学习 **路由算法(routing algorithm)**，路由算法是从发送方到接收方的众多路径中确定一条通过路由器网络的好的路径（等价于路由）。通常，一条好路径指的是最低开销路径。然而我们将看到，实践中现实世界还关心诸如策略之类的问题（例如，有一个规则是“属于组织 Y 的路由器 X 不应转发任何来源于组织 Z 所属网络的分组”）。我们注意到无论网络控制平面采用每路由器控制方法，还是采用逻辑集中式控制方法，必定总是存在一条定义良好的一连串路由器，使得分组从发送主机到接收主机跨越网络“旅行”。因此，计算这些路径的路由选择算法是十分重要的，是 10 个十分重要的网络问题之一。

我们可以用“图”这一概念来抽象路由问题。我们知道 **图(Graph)**：G = (N, E) 是一个 N 个节点和 E 条边的集合。其中每条边是取自 N 的一对节点。在网络层路由问题中，路由器被抽象为节点，这是做出分组转发决定的点，中间的物理链路被抽象为边，你可以看 5-3 所示的一个例子。若要查看某些表示实际网络的图，参见［Dodge 2016； Cheswick 2000］；对于基于不同的图模型建模因特网的好坏的讨论，参见［Zegura 1997 ； Faloutsos 1999 ； Li 2004］。

如图 5-3 所示，一条边还有一个值表示它的开销。显然，这是一个有权图。通常，一条边的开销可反映出对应链路的物
理长度（例如一条越洋链路的开销可能比一条短途陆地链路的开销高），它的链路速度，或与该链 路相关的金钱上的开销。为了我们的目的，我们只将这些链路开销看成是给定的，而不必操心这些值是如何确定的。对于 E 中的任一条边 `(x, y)`，我们用 `c(x, y)` 表示节点 x 和 y 间边的开销。如果节点对 (x, y）不属于 E，则 `c(x, y) = 正无穷`。 此外，我们在这里考虑的都是无向图（即图的边没有方向），因此边 (x, y) 与边(y, x)是相同的并且 c(x, y) = c(y, x)。然而，我们将学习的算法能够很容易地扩展到在每个方向有不同开销的有向图。如果(x, y) 属于 E，节点 y 也被称为节点 x 的 **邻接节点(neighbor)**。

![一个计算机网络被抽象为图](illustrations/5-3-一个计算机网络被抽象为图.png)

在图抽象中为各条边指定了开销后，路由选择算法的目标就是找岀从源到目的地间的最低开销路径。为了使问题更为精确，回想在图 `G = (N, E)`中的一条 **路径(path)** 是一个节点序列 `(x1, x2, ..., xp)`，这样每一个对 `(x1, x2)，(x2, x3), ..., (x p-1, xp)` 是 E 中的边。路径 (x1, x2, ..., xp) 的开销就是沿着路径所有边的开销的总和，即 `c(x1, X2) + c(x2, x3) + ... + c(x p-1, xp)`。给定任何两个节点 x 和 y，一般在这两个节点之间有许多条路径，每条路径都有一个开销。这些路径中的一条(或多条)为最低开销路径(least-cost path)。因此最低开销路径问题很显然是：找出源和目的地之间具有最低开销的一条路经。例如，在图 5-3 中，源节点 u 和目的节点 w 之间的最低开销路径是(u, x, y, w)，具有的路径开销是 3。

作为一个简单练习，试找出图 5-3 中从节点 u 到节点 z 的最低开销路径，并要反映出你是如何算出该路径的。如果你像大多数人一样，通过考察图 5-3，跟踪几条从 u 到 z 的路由，你就能找出从 u 到 z 的路径，然后以某种方式来确信你所选择的路径就是所有可能的路径中具有最低开销的路径。（你考察过 u 到 z 之间的所有 17 条可能的路径吗？很可能没有！）这种计算就是一种集中式路由选择算法的例子，即路由选择算法在一个位置（你的大脑中）运行，该位置具有网络的完整信息。一般而言，路由选择算法的一种分类方式是根据该算法是集中式还是分散式来划分。

- **集中式路由选择算法(centralized routing algorithm)** 用完整的、全局性的网络信息计算岀从源到目的地之间的最低开销路径。也就是说，该算法以所有节点之间的连通性及所有链路的开销为输入。这就要求该算法在真正开始计算以前，要以某 种方式获得这些信息。计算本身可在某个场点（例如，图 5-2 中所示的逻辑集中式控制器）进行，或在每台路由器的路由选择组件中重复进行（例如在图 5-1 中）。然而，这里的主要区别在于，集中式算法具有关于连通性和链路开销方面的完整信息。具有全局状态信息的算法常被称作 **链路状态(Link State, LS)算法**，因为该算法必须知道网络中每条链路的开销。我们将在 5-2-1 节中学习 LS 算法。
- 在 **分散式路由选择算法(decentralized routing algorithm)** 中，路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息。相反，每个节点仅有与其直接相连链路的开销知识即可开始工作。然后，通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径。我们将在后面的 5-2-2 节学习一个称为 **距离向量(Distance-Vector, DV)算法** 的分散式路由选择算法。之所以叫作 DV 算法，是因为每个节点维护到网络中所有其他节点的开销（距离）估计的向量。这种分散式算法，通过相邻路由器之间的交互式报文交换，更为适合路由器直接交互的控制平面，就像在图 5-1 中那样。

路由选择算法的第二种广义分类方式是根据算法是静态的还是动态的进行分类。在 **静态路由选择算法(static routing algorithm)** 中，路由随时间的变化非常缓慢，通常是人为进行调整（如人为手工编辑一条链路开销）。**动态路由选择算法(dynamic routing algorithm)** 随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性地运行或直接响应拓扑或链路开销的变化而运行。虽然动态算法易于对网络的变化做岀反应，但也更容易受诸如路由选择循环、路由振荡之类问题的影响。

路由选择算法的第三种分类方式是根据它是负载敏感的还是负载迟钝的进行划分。在 **负载敏感算法(load-sensitive algorithm)** 中，链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该拥塞链路来选择路由。而早期的 ARPAnet 路由选择算法就是负载敏感的[McQuillan 1980]，所以遇到了许多难题[Huitema 1998]。当今的因特网路由选择算法（如 RIP、OSPF 和 BGP）都是 **负载迟钝的(load-insensitive)**，因为某条链路的开销不明确地反映其当前（或最近）的拥塞水平。

### 5.2.1. 链路状态(LS)路由算法

前面讲过，在链路状态算法中，网络拓扑和所有的链路开销都是已知的，也就是说可用作 LS 算法的输入。实践中这是通过让每个节点向网络中所有其他节点广播链路状态分 组来完成的，其中每个链路状态分组包含它所连接的链路的标识和开销。在实践中（例如 使用因特网的 OSPF 路由选择协议，讨论见 5-3 节），这经常由 **链路状态广播(link state broadcast)算法**［Perhnan 1999］来完成。节点广播的结果是所有节点都具有该网络的 一、完整的视图。于是每个节点都能够像其他节点一样，运行 LS 算法并计算出相同的最低开销路径集合。

我们下面给出的链路状态路由选择算法叫作 Dijkstra 算法，该算法以其发明者命名。一个密切相关的算法是 Prim 算法，有关图算法的一般性讨论参见［Cormen 2001］。Dijkstra 算法计算从某节点（源节点，我们称之为 u）到网络中所有其他节点的最低开销路径。Dijkstra 算法是迭代算法，其特点是经算法的第 k 次迭代后，可以计算出 k 个目的节点的最低开销路径，我们定义下列记号。

- D(v)：从源节点到目的节点 v 的最低开销。
- p(v)：在源节点到 v 的最低开销路径上，v 的邻接节点。
- N'：当前最低开销路径的节点集合。

该集中式路由选择算法由一个初始化步骤和其后的循环组成。循环执行的次数与网络中节点个数相同。一旦终止，该算法就计算出了从源节点 u 到网络中每个其他节点的最短路径。

```py
初始化
N' = {u}
for all node v
  if v is a neighbor of u:
    D(v) = c(u, v)
  else D(v) = 正无穷

loop
  find w not in N' 这样 D(w) 是最小开销
  add w to N'
  update D(v) for each neighbor v of w and not in N':
    D(v) = min(D(v), D(w) + c(w, v))
  /* v 的新开销要么是原来的 D(v)，要么是到 w 的最小开销加上 w 到 v 的开销 */
until N' = N
```

举一个例子，考虑图 5-3 中的网络，计算从 u 到所有可能目的地的最低开销路径。该算法的计算过程以表格方式总结于表 5-1 中，表中的每一行给岀了迭代结束时该算法的变量的值。我们详细地考虑前几个步骤。

| 步骤 | N'     | D(v), p(v) | D(w), p(w) | D(x), p(x) | D(y), p(y) | D(z), p(z) |
| ---- | ------ | ---------- | ---------- | ---------- | ---------- | ---------- |
| 0    | u      | 2, u       | 5, u       | 1, u       | 正无穷     | 正无穷     |
| 1    | ux     | 2, u       | 4, x       |            | 2, x       | 正无穷     |
| 2    | uxy    | 2, u       | 3, y       |            |            | 4, y       |
| 3    | uxyv   |            | 3, y       |            |            | 4, y       |
| 4    | uxyvw  |            |            |            | 4, y       |            |
| 5    | uxyvwz |            |            |            |            |            |

- 在初始化步骤，从 u 到与其直接相连的邻居 v，x，w 的当前已知最低开销路径分别初始化为 2、1 和 5。特别值得注意的是，到 w 的开销被设为 5（尽管我们很快就会看见确实存在一条开销更小的路径），因为这是从 u 到 w 的直接（一跳）链路开销。到 y 与 z 的开销被设为无穷大，因为它们不直接与 u 连接。
- 在第一次迭代中，我们观察那些还未加到集合 N' 中的节点，并且找岀在前一次迭代结束时具有最低开销的节点。那个节点便是 x，其开销是 1，因此 x 被加到集合 N' 中。于是 LS 算法中的第 12 行中的程序被执行，以更新所有节点卩的 D3）,产 生表 5-1 中第 2 行（步骤 1）所示的结果。到少的路径开销未变。经过节点 x 到 w（在初始化结束时其开销为 5）的路径开销被发现为 4。因此这条具有更低开销的路 径被选中，且沿从"开始的最短路径上"的前一节点被设为策。类似地，到 y （经 过兀）的开销被计算为 2,且该表也被相应地更新。
- 在第二次迭代时，节点勿与 y 被发现具有最低开销路径（2）,并且我们任意改变次 序将 y 加到集合 N' 中，使得 M 中含有"、久和九 到仍不在 M 中的其余节点（即节 点如 ⑷ 和 z）的开销通过 LS 算法中的第 12 行进行更新，产生如表 5-1 中第 3 行所不的结果。
- 如此等等。

当 LS 算法终止时，对于每个节点，我们都得到从源节点沿着它的最低开销路径的前一节点。对于每个前一节点，我们又有它的前一节点，以此方式我们可以构建从源节点到所有目的节点的完整路径。通过对每个目的节点存放从 u 到目的地的最低开销路径上的下一跳节点，在一个节点（如节 ）中的转发表则能够根据此信息 而构建。图 5-4 显示了对于图 5-3 中 的网络产生的最低开销路径和 u 中的转发表。

![5-4-对于节点u的最低开销路径和转发表](illustrations/5-4-对于节点u的最低开销路径和转发表.png)



### 5.2.2. 距离向量(DV)路由算法

## 5.3. 因特网中自治系统内部的路由选择：OSPF

## 5.4. ISP 之间的路由选择：BGP

## 5.5. SDN 控制平面

## 5.6. ICMP：因特网控制报文协议

## 5.7. 网络管理和 SNMP
